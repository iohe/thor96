From 2c32c7dad6f7d0ae0b3393f98f5579cd4808bf5d Mon Sep 17 00:00:00 2001
From: Ioan Herisanu <ioan.herisanu.dev@gmail.com>
Date: Sat, 13 Jun 2020 18:13:02 +0300
Subject: [PATCH] Thor96 Einfochips

---
 arch/arm64/boot/dts/freescale/Makefile        |   12 +-
 .../dts/freescale/fsl-imx8mq-thor96-b3.dts    |   47 +
 .../fsl-imx8mq-thor96-dcss-adv7535-b3.dts     |   16 +
 .../fsl-imx8mq-thor96-dcss-adv7535.dts        |   16 +
 .../fsl-imx8mq-thor96-dcss-adv7535.dtsi       |   76 +
 .../fsl-imx8mq-thor96-dcss-rm67191-b3.dts     |   20 +
 .../fsl-imx8mq-thor96-dcss-rm67191.dts        |   16 +
 .../fsl-imx8mq-thor96-dcss-rm67191.dtsi       |  127 ++
 .../fsl-imx8mq-thor96-dual-display-b3.dts     |   47 +
 .../fsl-imx8mq-thor96-dual-display.dts        |   42 +
 .../fsl-imx8mq-thor96-lcdif-adv7535-b3.dts    |   16 +
 .../fsl-imx8mq-thor96-lcdif-adv7535.dts       |   16 +
 .../fsl-imx8mq-thor96-lcdif-adv7535.dtsi      |   71 +
 .../fsl-imx8mq-thor96-lcdif-rm67191-b3.dts    |   16 +
 .../fsl-imx8mq-thor96-lcdif-rm67191.dts       |   16 +
 .../fsl-imx8mq-thor96-lcdif-rm67191.dtsi      |  121 ++
 .../freescale/fsl-imx8mq-thor96-mipi-csi.dts  |  157 ++
 .../freescale/fsl-imx8mq-thor96-otg-host.dts  |   26 +
 .../dts/freescale/fsl-imx8mq-thor96-root.dts  |  110 ++
 .../boot/dts/freescale/fsl-imx8mq-thor96.dts  |  901 ++++++++++
 arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi |   14 +-
 arch/arm64/configs/defconfig                  |  133 ++
 drivers/extcon/Kconfig                        |    8 +
 drivers/extcon/Makefile                       |    1 +
 drivers/extcon/extcon-usb-gpio-vbus.c         |  280 +++
 drivers/gpu/drm/imx/nwl_dsi-imx.c             |   57 +-
 drivers/mtd/spi-nor/spi-nor.c                 |   25 +-
 drivers/net/can/spi/mcp251x.c                 |    1 +
 .../broadcom/brcm80211/brcmfmac/bcmsdh.c      |    1 +
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |  266 ++-
 .../broadcom/brcm80211/brcmfmac/cfg80211.h    |    8 +-
 .../broadcom/brcm80211/brcmfmac/chip.c        |  236 ++-
 .../broadcom/brcm80211/brcmfmac/chip.h        |    8 +
 .../broadcom/brcm80211/brcmfmac/common.c      |   81 +-
 .../broadcom/brcm80211/brcmfmac/common.h      |    3 +
 .../broadcom/brcm80211/brcmfmac/core.h        |    1 +
 .../broadcom/brcm80211/brcmfmac/debug.h       |    1 +
 .../broadcom/brcm80211/brcmfmac/feature.c     |    1 +
 .../broadcom/brcm80211/brcmfmac/feature.h     |    3 +-
 .../broadcom/brcm80211/brcmfmac/fweh.h        |   28 +-
 .../broadcom/brcm80211/brcmfmac/fwil_types.h  |   16 +
 .../broadcom/brcm80211/brcmfmac/fwsignal.c    |   70 +-
 .../broadcom/brcm80211/brcmfmac/p2p.c         |   56 +-
 .../broadcom/brcm80211/brcmfmac/p2p.h         |    9 +-
 .../broadcom/brcm80211/brcmfmac/pcie.c        |    3 +-
 .../broadcom/brcm80211/brcmfmac/sdio.c        |  206 ++-
 .../broadcom/brcm80211/brcmfmac/sdio.h        |   83 +-
 .../broadcom/brcm80211/brcmfmac/usb.c         |    7 +-
 .../broadcom/brcm80211/include/brcm_hw_ids.h  |    1 +
 .../broadcom/brcm80211/include/brcmu_wifi.h   |    1 +
 .../broadcom/brcm80211/include/chipcommon.h   |  193 ++-
 drivers/spi/spidev.c                          |    1 +
 drivers/usb/dwc3/dwc3-of-simple.c             |   41 +
 drivers/usb/serial/cp210x.c                   |   36 +-
 drivers/usb/serial/option.c                   |   33 +
 drivers/usb/serial/usb_wwan.c                 |   15 +
 include/linux/ieee80211.h                     |    1 +
 include/linux/mmc/sdio_ids.h                  |    1 +
 include/net/cfg80211.h                        |   26 +-
 include/uapi/linux/nl80211.h                  |  134 +-
 net/wireless/core.h                           |    5 +
 net/wireless/nl80211.c                        |   54 +-
 net/wireless/nl80211.h                        |    2 +
 net/wireless/sme.c                            |   45 +-
 net/wireless/util.c                           |    3 +
 sound/soc/codecs/Kconfig                      |    9 +
 sound/soc/codecs/Makefile                     |    4 +
 sound/soc/codecs/a2b24xx-i2c.c                |   64 +
 sound/soc/codecs/a2b24xx.c                    |  370 ++++
 sound/soc/codecs/a2b24xx.h                    |   37 +
 sound/soc/codecs/adi_a2b_i2c_commandlist.h    | 1525 +++++++++++++++++
 sound/soc/fsl/Kconfig                         |   27 +
 sound/soc/fsl/Makefile                        |    4 +
 sound/soc/fsl/imx-adau-a2b2428.c              |  197 +++
 sound/soc/fsl/imx_adau1361v1.c                |  227 +++
 75 files changed, 6328 insertions(+), 203 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191-b3.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-mipi-csi.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-otg-host.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-root.dts
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96.dts
 create mode 100644 drivers/extcon/extcon-usb-gpio-vbus.c
 create mode 100755 sound/soc/codecs/a2b24xx-i2c.c
 create mode 100755 sound/soc/codecs/a2b24xx.c
 create mode 100755 sound/soc/codecs/a2b24xx.h
 create mode 100755 sound/soc/codecs/adi_a2b_i2c_commandlist.h
 create mode 100644 sound/soc/fsl/imx-adau-a2b2428.c
 create mode 100644 sound/soc/fsl/imx_adau1361v1.c

diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index fcbca40bc8fa..cc33334a20ea 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -13,7 +13,7 @@ dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-ls2080a-rdb.dtb
 dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-ls2080a-simu.dtb
 dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-ls2088a-qds.dtb
 dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-ls2088a-rdb.dtb
- 
+
 dtb-$(CONFIG_ARCH_FSL_IMX8QM) += fsl-imx8qm-lpddr4-arm2.dtb \
 				 fsl-imx8qm-lpddr4-arm2-dom0.dtb \
 				 fsl-imx8qm-lpddr4-arm2-domu.dtb \
@@ -113,7 +113,15 @@ dtb-$(CONFIG_ARCH_FSL_IMX8MQ) += fsl-imx8mq-ddr3l-arm2.dtb \
 				 fsl-imx8mq-evk-root.dtb \
 				 fsl-imx8mq-evk-inmate.dtb \
 				 fsl-imx8mq-evk-dp.dtb \
-				 fsl-imx8mq-evk-edp.dtb
+				 fsl-imx8mq-evk-edp.dtb \
+				 fsl-imx8mq-thor96.dtb \
+				 fsl-imx8mq-thor96-root.dtb \
+				 fsl-imx8mq-thor96-lcdif-adv7535.dtb \
+				 fsl-imx8mq-thor96-lcdif-adv7535-b3.dtb \
+				 fsl-imx8mq-thor96-mipi-csi.dtb \
+				 fsl-imx8mq-thor96-dcss-adv7535.dtb \
+				 fsl-imx8mq-thor96-dcss-adv7535-b3.dtb
+
 dtb-$(CONFIG_ARCH_FSL_IMX8MM) += fsl-imx8mm-evk.dtb \
 				 fsl-imx8mm-evk-ak4497.dtb \
 				 fsl-imx8mm-evk-m4.dtb \
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-b3.dts
new file mode 100644
index 000000000000..682a6867629c
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-b3.dts
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-mipi-csi.dts"
+
+/delete-node/ &adv_bridge;
+
+&i2c1 {
+
+	synaptics_dsx_ts: synaptics_dsx_ts@20 {
+		compatible = "synaptics_dsx";
+		reg = <0x20>;
+		pinctrl-names = "default";
+		interrupts = <7 IRQ_TYPE_LEVEL_LOW>;
+		synaptics,diagonal-rotation;
+		status = "disabled";
+	};
+
+	adv_bridge: adv7535@3d {
+		compatible = "adi,adv7533";
+		reg = <0x3d>;
+		adi,addr-cec = <0x3b>;
+		adi,dsi-lanes = <4>;
+		status = "okay";
+
+		port {
+			adv7535_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_adv>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535-b3.dts
new file mode 100644
index 000000000000..da65728a093d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535-b3.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-b3.dts"
+#include "fsl-imx8mq-thor96-dcss-adv7535.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dts
new file mode 100644
index 000000000000..0ece383f6f25
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2017-2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+#include "fsl-imx8mq-thor96-dcss-adv7535.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dtsi
new file mode 100644
index 000000000000..b43c5bf0cd90
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-adv7535.dtsi
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	sound-hdmi {
+		status = "okay";
+	};
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&dcss {
+	status = "okay";
+	disp-dev = "mipi_disp";
+
+	clocks = <&clk IMX8MQ_CLK_DISP_APB_ROOT>,
+		 <&clk IMX8MQ_CLK_DISP_AXI_ROOT>,
+		 <&clk IMX8MQ_CLK_DISP_RTRM_ROOT>,
+		 <&clk IMX8MQ_CLK_DC_PIXEL>,
+		 <&clk IMX8MQ_CLK_DUMMY>,
+		 <&clk IMX8MQ_CLK_DISP_DTRC>;
+	clock-names = "apb", "axi", "rtrm", "pix_div", "pix_out", "dtrc";
+	assigned-clocks = <&clk IMX8MQ_CLK_DC_PIXEL>,
+			  <&clk IMX8MQ_CLK_DISP_AXI>,
+			  <&clk IMX8MQ_CLK_DISP_RTRM>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_800M>,
+				 <&clk IMX8MQ_SYS1_PLL_800M>;
+	assigned-clock-rates = <594000000>,
+			       <800000000>,
+			       <400000000>;
+
+	dcss_disp0: port@0 {
+		reg = <0>;
+
+		dcss_disp0_mipi_dsi: mipi_dsi {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&dcss_disp0_mipi_dsi>;
+		};
+	};
+
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+};
+
+&adv_bridge {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191-b3.dts
new file mode 100644
index 000000000000..93d8293e158b
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191-b3.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-b3.dts"
+#include "fsl-imx8mq-thor96-dcss-rm67191.dtsi"
+
+&mipi_dsi {
+	Mezzanine_DSI;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dts
new file mode 100644
index 000000000000..0eb22e06c11e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2017-2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+#include "fsl-imx8mq-thor96-dcss-rm67191.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dtsi
new file mode 100644
index 000000000000..ac5de5cbd8a5
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dcss-rm67191.dtsi
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	sound-hdmi {
+		status = "disabled";
+	};
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&dcss {
+	status = "okay";
+	disp-dev = "mipi_disp";
+
+	clocks = <&clk IMX8MQ_CLK_DISP_APB_ROOT>,
+		 <&clk IMX8MQ_CLK_DISP_AXI_ROOT>,
+		 <&clk IMX8MQ_CLK_DISP_RTRM_ROOT>,
+		 <&clk IMX8MQ_CLK_DC_PIXEL>,
+		 <&clk IMX8MQ_CLK_DUMMY>,
+		 <&clk IMX8MQ_CLK_DISP_DTRC>;
+	clock-names = "apb", "axi", "rtrm", "pix_div", "pix_out", "dtrc";
+
+	assigned-clocks = <&clk IMX8MQ_CLK_DC_PIXEL>,
+			  <&clk IMX8MQ_CLK_DISP_AXI>,
+			  <&clk IMX8MQ_CLK_DISP_RTRM>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_800M>,
+				 <&clk IMX8MQ_SYS1_PLL_800M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <600000000>,
+		               <800000000>,
+		               <0>,
+					   <400000000>,
+					   <599999999>;
+
+	dcss_disp0: port@0 {
+		reg = <0>;
+
+		dcss_disp0_mipi_dsi: mipi_dsi {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+			  <&clk IMX8MQ_CLK_DSI_CORE>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_266M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <24000000>,
+			<266000000>,
+			<0>,
+			<599999999>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&dcss_disp0_mipi_dsi>;
+		};
+	};
+
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+
+	panel@0 {
+		compatible = "raydium,rm67191";
+		reg = <0>;
+		dsi-lanes = <4>;
+		panel-width-mm = <68>;
+		panel-height-mm = <121>;
+
+		display-timings {
+			timing {
+				clock-frequency = <132000000>;
+				hactive = <1080>;
+				vactive = <1920>;
+				hfront-porch = <20>;
+				hsync-len = <2>;
+				hback-porch = <34>;
+				vfront-porch = <10>;
+				vsync-len = <5>;
+				vback-porch = <4>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		port {
+			panel1_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@2 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel1_in>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display-b3.dts
new file mode 100644
index 000000000000..32bb2a170d2a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display-b3.dts
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-lcdif-adv7535-b3.dts"
+
+/ {
+	display-subsystem {
+		status = "okay";
+	};
+
+	sound-hdmi {
+		status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "okay";
+};
+
+&dcss {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1280>, <720>;
+};
+
+&mipi_dsi {
+	 Dual_disp;
+	 /delete-node/ Mezzanine_DSI;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display.dts
new file mode 100644
index 000000000000..f23e9fc0ca37
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-dual-display.dts
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-lcdif-adv7535.dts"
+
+/ {
+	display-subsystem {
+		status = "okay";
+	};
+
+	sound-hdmi {
+		status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "okay";
+};
+
+&dcss {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1280>, <720>;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535-b3.dts
new file mode 100644
index 000000000000..32e5834b8615
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535-b3.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-b3.dts"
+#include "fsl-imx8mq-thor96-lcdif-adv7535.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dts
new file mode 100644
index 000000000000..330c356aba7d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2017-2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+#include "fsl-imx8mq-thor96-lcdif-adv7535.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dtsi
new file mode 100644
index 000000000000..1bea8b672229
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-adv7535.dtsi
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+
+	sound-hdmi {
+		status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1280>, <720>;
+
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+};
+
+&adv_bridge {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191-b3.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191-b3.dts
new file mode 100644
index 000000000000..a69d1c466ae2
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191-b3.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96-b3.dts"
+#include "fsl-imx8mq-thor96-lcdif-rm67191.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dts
new file mode 100644
index 000000000000..8a599cca5670
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dts
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2017-2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+#include "fsl-imx8mq-thor96-lcdif-rm67191.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dtsi
new file mode 100644
index 000000000000..2aa211942f5c
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-lcdif-rm67191.dtsi
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+
+	sound-hdmi {
+		status = "disabled";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1080>, <1920>;
+
+	assigned-clocks = <&clk IMX8MQ_CLK_LCDIF_PIXEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rate = <120000000>,
+			      <0>,
+			      <599999999>;
+
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	as_bridge;
+	sync-pol = <1>;
+	assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+			  <&clk IMX8MQ_CLK_DSI_CORE>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_266M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <24000000>,
+			       <266000000>,
+			       <0>,
+			       <599999999>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+
+	panel@0 {
+		compatible = "raydium,rm67191";
+		reg = <0>;
+		pinctrl-0 = <&pinctrl_mipi_dsi_en>;
+		reset-gpio = <&gpio5 6 GPIO_ACTIVE_HIGH>;
+		dsi-lanes = <4>;
+		panel-width-mm = <68>;
+		panel-height-mm = <121>;
+		port {
+			panel1_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@2 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel1_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-thor96 {
+		pinctrl_mipi_dsi_en: mipi_dsi_en {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI1_SCLK_GPIO5_IO6	0x16
+			>;
+		};
+	};
+};
+
+&synaptics_dsx_ts {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-mipi-csi.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-mipi-csi.dts
new file mode 100644
index 000000000000..5a8e3a5897e6
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-mipi-csi.dts
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+
+&iomuxc {
+
+ imx8mq-thor96 {
+
+	pinctrl_csi1: csi1grp {
+		fsl,pins = <
+			MX8MQ_IOMUXC_GPIO1_IO03_GPIO1_IO3		0x19
+			MX8MQ_IOMUXC_GPIO1_IO15_CCMSRCGPCMIX_CLKO2	0x59
+		>;
+		};
+
+	pinctrl_csi2: csi2grp {
+		fsl,pins = <
+			MX8MQ_IOMUXC_GPIO1_IO05_GPIO1_IO5				0x19
+			MX8MQ_IOMUXC_GPIO1_IO14_CCMSRCGPCMIX_CLKO1		0x59
+		>;
+		};
+	};
+};
+
+
+&i2c2 {
+
+	ov5640_mipi2: ov5640_mipi@3c {
+		compatible = "ovti,ov5640_mipi";
+		reg = <0x3c>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi2>;
+
+		clocks = <&clk IMX8MQ_CLK_CLKO2>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&clk IMX8MQ_CLK_CLKO2>,
+				  <&clk IMX8MQ_CLK_CLKO2>;
+		assigned-clock-parents = <&clk IMX8MQ_SYS2_PLL_200M>;
+		assigned-clock-rates = <0>, <25000000>;
+		csi_id = <0>;
+		pwn-gpios = <&gpio1 5 GPIO_ACTIVE_HIGH>;
+		rst-gpios = <&gpio3 13 GPIO_ACTIVE_LOW>;
+		mclk = <25000000>;
+		mclk_source = <0>;
+		port {
+			ov5640_mipi2_ep: endpoint {
+			remote-endpoint = <&mipi2_sensor_ep>;
+			};
+		};
+	};
+
+};
+
+&i2c3 {
+
+	ov5640_mipi: ov5640_mipi@3c {
+		compatible = "ovti,ov5640_mipi";
+		reg = <0x3c>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi1>;
+		clocks = <&clk IMX8MQ_CLK_CLKO2>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&clk IMX8MQ_CLK_CLKO2>,
+				  <&clk IMX8MQ_CLK_CLKO2>;
+		assigned-clock-parents = <&clk IMX8MQ_SYS2_PLL_200M>;
+		assigned-clock-rates = <0>, <20000000>;
+		csi_id = <0>;
+		pwn-gpios = <&gpio1 3 GPIO_ACTIVE_HIGH>;
+		rst-gpios = <&gpio3 12 GPIO_ACTIVE_LOW>;
+		mclk = <20000000>;
+		mclk_source = <0>;
+		port {
+			ov5640_mipi1_ep: endpoint {
+				remote-endpoint = <&mipi1_sensor_ep>;
+			};
+		};
+	};
+
+};
+
+&ov5640_mipi {
+	status = "okay";
+};
+
+&ov5640_mipi2 {
+	status = "okay";
+};
+
+&csi1_bridge {
+	fsl,mipi-mode;
+	fsl,two-8bit-sensor-mode;
+	status = "okay";
+
+	port {
+		csi1_ep: endpoint {
+			remote-endpoint = <&csi1_mipi_ep>;
+		};
+	};
+};
+
+&csi2_bridge {
+	fsl,mipi-mode;
+	fsl,two-8bit-sensor-mode;
+	status = "okay";
+
+	port {
+		csi2_ep: endpoint {
+			remote-endpoint = <&csi2_mipi_ep>;
+		};
+	};
+};
+
+&mipi_csi_1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	port {
+		mipi1_sensor_ep: endpoint1 {
+			remote-endpoint = <&ov5640_mipi1_ep>;
+			data-lanes = <1 2>;
+		};
+
+		csi1_mipi_ep: endpoint2 {
+			remote-endpoint = <&csi1_ep>;
+		};
+	};
+};
+
+&mipi_csi_2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	port {
+		mipi2_sensor_ep: endpoint1 {
+			remote-endpoint = <&ov5640_mipi2_ep>;
+			data-lanes = <1 2>;
+		};
+
+		csi2_mipi_ep: endpoint2 {
+			remote-endpoint = <&csi2_ep>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-otg-host.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-otg-host.dts
new file mode 100644
index 000000000000..79a2a4cf7e41
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-otg-host.dts
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+
+
+&usb_dwc3_0 {
+
+	dr_mode = "host";
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-root.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-root.dts
new file mode 100644
index 000000000000..1dd4b7e79639
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96-root.dts
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "fsl-imx8mq-thor96.dts"
+
+/ {
+	interrupt-parent = <&gic>;
+};
+
+/delete-node/ &gpc;
+
+&CPU_SLEEP {
+	/* We are not using GPC for now, need set 0 to avoid hang */
+	arm,psci-suspend-param = <0x0>;
+};
+
+&clk {
+	init-on-array = <IMX8MQ_CLK_DRAM_CORE IMX8MQ_CLK_AHB
+			 IMX8MQ_CLK_NOC IMX8MQ_CLK_NOC_APB
+			 IMX8MQ_CLK_USB_BUS
+			 IMX8MQ_CLK_MAIN_AXI IMX8MQ_CLK_A53_CG
+			 IMX8MQ_CLK_AUDIO_AHB IMX8MQ_CLK_TMU_ROOT
+			 IMX8MQ_CLK_DRAM_APB
+			 IMX8MQ_CLK_UART2_ROOT
+			 IMX8MQ_CLK_UART2
+			 IMX8MQ_CLK_NAND_USDHC_BUS>;
+};
+
+&iomuxc {
+	imx8mq-thor96 {
+		/*
+		 * Used for the 2nd Linux.
+		 * TODO: M4 may use these pins.
+		 */
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_UART2_RXD_UART2_DCE_RX	0x49
+				MX8MQ_IOMUXC_UART2_TXD_UART2_DCE_TX	0x49
+			>;
+		};
+	};
+};
+
+&{/busfreq} {
+	/* Disable busfreq, to avoid 1st Linux busfreq crash other inmates */
+	status = "disabled";
+};
+
+&resmem {
+	jh_reserved: jh@0xfdc00000 {
+		no-map;
+		reg = <0 0xfdc00000 0x0 0x400000>;
+	};
+
+	inmate_reserved: inmate@0xc0000000 {
+		no-map;
+		reg = <0 0xc0000000 0x0 0x3dc00000>;
+	};
+
+	loader_reserved: loader@0xbff00000 {
+		no-map;
+		reg = <0 0xbff00000 0x0 0x00100000>;
+	};
+
+	ivshmem_reserved: ivshmem@0xbfe00000 {
+		no-map;
+		reg = <0 0xbfe00000 0x0 0x00100000>;
+	};
+
+	ivshmem2_reserved: ivshmem2@0xbfd00000 {
+		no-map;
+		reg = <0 0xbfd00000 0x0 0x00100000>;
+	};
+
+	pci_reserved: pci@0xbfc00000 {
+		no-map;
+		reg = <0 0xbfb00000 0x0 0x00200000>;
+	};
+};
+
+&uart1 {
+	/* uart2 is used by the 2nd OS, so configure pin and clk */
+	pinctrl-0 = <&pinctrl_uart1>, <&pinctrl_uart2>;
+	assigned-clocks = <&clk IMX8MQ_CLK_UART1>,
+			<&clk IMX8MQ_CLK_UART2>;
+	assigned-clock-parents = <&clk IMX8MQ_CLK_25M>,
+			<&clk IMX8MQ_CLK_25M>;
+};
+
+&usdhc1 {
+	status = "disabled";
+};
+
+&usdhc2 {
+	/* sdhc1 is used by 2nd linux, configure the pin */
+	pinctrl-0 = <&pinctrl_usdhc1>, <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc1>, <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc1>, <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96.dts
new file mode 100644
index 000000000000..b89611763046
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-thor96.dts
@@ -0,0 +1,901 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8mq.dtsi"
+
+/ {
+	model = "Freescale i.MX8MQ THOR96";
+	compatible = "fsl,imx8mq-thor96", "fsl,imx8mq";
+
+	chosen {
+		bootargs = "console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200";
+		stdout-path = &uart1;
+	};
+
+	clocks {
+		clk24M: can_clock {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <20000000>;
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usdhc1_vmmc: usdhc1_vmmc {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio3 3 GPIO_ACTIVE_HIGH>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		reg_usdhc2_vmmc: usdhc2_vmmc {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+			off-on-delay = <20000>;
+			enable-active-high;
+		};
+
+		reg_gpio_dvfs: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_dvfs>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1000000>;
+			regulator-name = "gpio_dvfs";
+			regulator-type = "voltage";
+			gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
+			states = <900000 0x1 1000000 0x0>;
+		};
+	};
+
+	modem_reset: modem-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio3 5 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <2000>;
+		reset-post-delay-ms = <40>;
+		#reset-cells = <0>;
+	};
+
+	can_reset: can-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio3 25 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <2000>;
+		reset-post-delay-ms = <40>;
+		#reset-cells = <0>;
+	};
+
+	extcon_usb0: extcon_usb0 {
+		compatible = "linux,extcon-usb-gpio-vbus";
+		id-gpio = <&gpio1 10 GPIO_ACTIVE_HIGH>;
+		vbus-gpio = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx8mq-evk-cdnhdmi",
+				"fsl,imx-audio-cdnhdmi";
+		model = "imx-audio-hdmi";
+		audio-cpu = <&sai4>;
+		protocol = <1>;
+		hdmi-out;
+		constraint-rate = <44100>,
+				<88200>,
+				<176400>,
+				<32000>,
+				<48000>,
+				<96000>,
+				<192000>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif1>;
+		spdif-out;
+		spdif-in;
+	};
+
+	sound-hdmi-arc {
+		compatible = "fsl,imx-audio-spdif";
+		model = "imx-hdmi-arc";
+		spdif-controller = <&spdif2>;
+		spdif-in;
+	};
+
+	sound-adau1361 {
+		compatible = "fsl,imx-adau1361";
+		model = "adau1361-audio";
+		audio-cpu = <&sai1>;
+		audio-codec = <&adau1361>;
+	};
+
+	sound-ad2428w {
+		compatible = "fsl,imx-ad2428w";
+		model = "ad24xx-a2b-bus";
+		audio-cpu = <&sai3>;
+		audio-codec = <&a2b24xx>;
+	};
+};
+
+&clk {
+	assigned-clocks = <&clk IMX8MQ_AUDIO_PLL1>, <&clk IMX8MQ_AUDIO_PLL2>;
+	assigned-clock-rates = <786432000>, <722534400>;
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx8mq-thor96 {
+		/*use as a micro switch */
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_NAND_READY_B_GPIO3_IO16		0x19
+				MX8MQ_IOMUXC_NAND_WE_B_GPIO3_IO17		0x19
+				MX8MQ_IOMUXC_NAND_WP_B_GPIO3_IO18		0x19
+			>;
+		};
+
+		pinctrl_ecspi1: ecspi1grp { /*can spi interface*/
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI1_SCLK_ECSPI1_SCLK    0x16
+				MX8MQ_IOMUXC_ECSPI1_MOSI_ECSPI1_MOSI    0x16
+				MX8MQ_IOMUXC_ECSPI1_MISO_ECSPI1_MISO    0x16
+				MX8MQ_IOMUXC_GPIO1_IO01_GPIO1_IO1		0x16
+				MX8MQ_IOMUXC_SAI5_MCLK_GPIO3_IO25 		0x19 /*reset*/
+				MX8MQ_IOMUXC_GPIO1_IO06_GPIO1_IO6		0x19
+
+			>;
+		};
+		pinctrl_ecspi1_exp: ecspi1expgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI1_SCLK_ECSPI1_SCLK    0x16
+				MX8MQ_IOMUXC_ECSPI1_MOSI_ECSPI1_MOSI    0x16
+				MX8MQ_IOMUXC_ECSPI1_MISO_ECSPI1_MISO    0x16
+				MX8MQ_IOMUXC_ECSPI1_SS0_ECSPI1_SS0      0x16
+			>;
+		};
+
+		pinctrl_ecspi2_exp: ecspi2expgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK  0x16
+				MX8MQ_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI  0x16
+				MX8MQ_IOMUXC_ECSPI2_MISO_ECSPI2_MISO  0x16
+				MX8MQ_IOMUXC_ECSPI2_SS0_ECSPI2_SS0	  0x16
+			>;
+		};
+
+		pinctrl_ecspi2: ecspi2grp {/* zigbee spi interface */
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK  0x049
+				MX8MQ_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI  0x049
+				MX8MQ_IOMUXC_ECSPI2_MISO_ECSPI2_MISO  0x049
+				MX8MQ_IOMUXC_GPIO1_IO08_GPIO1_IO8	0xd6 /*chip select*/
+			>;
+		};
+
+		pinctrl_zigbee_ctrl: zigbectrlgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_RX_GPIO5_IO4 		0x016	/*reset*/
+				MX8MQ_IOMUXC_NAND_DATA05_GPIO3_IO11     0x016  /* Int */
+				MX8MQ_IOMUXC_NAND_DATA04_GPIO3_IO10     0x016 /* wake*/
+			>;
+		};
+
+		pinctrl_ls_exp_gpio: ls_exp_gpio_grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO03_GPIO1_IO3		0x19
+				MX8MQ_IOMUXC_GPIO1_IO05_GPIO1_IO5		0x19
+				MX8MQ_IOMUXC_SD1_DATA5_GPIO2_IO7		0x19
+				MX8MQ_IOMUXC_SD1_DATA6_GPIO2_IO8       0x19
+				MX8MQ_IOMUXC_SD1_RESET_B_GPIO2_IO10    0x19
+				MX8MQ_IOMUXC_SD1_STROBE_GPIO2_IO11     0x19
+				MX8MQ_IOMUXC_NAND_CE1_B_GPIO3_IO2      0x19
+				MX8MQ_IOMUXC_SAI5_RXC_GPIO3_IO20       0x19
+				MX8MQ_IOMUXC_SAI5_RXD0_GPIO3_IO21      0x19
+				MX8MQ_IOMUXC_SAI5_RXD3_GPIO3_IO24      0x19
+			>;
+		};
+
+		pinctrl_usb_hub_rst:usb_hub_rst {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5       0x19
+			>;
+		};
+
+		pinctrl_hp_det_b:hp_det_b {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI3_MCLK_GPIO5_IO2       0x19
+			>;
+		};
+		pinctrl_fan_on:fan_on {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI2_MCLK_GPIO4_IO27       0x19
+			>;
+		};
+
+		pinctrl_wl_led:wl_led {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI1_RXC_GPIO4_IO1       0x19
+			>;
+		};
+
+		pinctrl_user_leds:user_ledsgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI2_RXFS_GPIO4_IO21        0x19
+				MX8MQ_IOMUXC_SAI2_RXC_GPIO4_IO22        0x19
+				MX8MQ_IOMUXC_SAI3_RXFS_GPIO4_IO28       0x19
+				MX8MQ_IOMUXC_SAI3_RXC_GPIO4_IO29       0x19
+			>;
+		};
+
+		pinctrl_dsi_ctrl:dsictrlgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_NAND_RE_B_GPIO3_IO15	0x16
+				MX8MQ_IOMUXC_NAND_CE3_B_GPIO3_IO4   0x16
+			>;
+		};
+
+		pinctrl_wl_reg_on:wl_reg_on {
+			fsl,pins = <
+				MX8MQ_IOMUXC_NAND_CE2_B_GPIO3_IO3	0x17059
+			>;
+		};
+
+		pinctrl_fec1: fec1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ENET_MDC_ENET1_MDC		0x4
+				MX8MQ_IOMUXC_ENET_MDIO_ENET1_MDIO	0x24
+				MX8MQ_IOMUXC_ENET_TD3_ENET1_RGMII_TD3	0x1c
+				MX8MQ_IOMUXC_ENET_TD2_ENET1_RGMII_TD2	0x1c
+				MX8MQ_IOMUXC_ENET_TD1_ENET1_RGMII_TD1	0x1c
+				MX8MQ_IOMUXC_ENET_TD0_ENET1_RGMII_TD0	0x1c
+				MX8MQ_IOMUXC_ENET_RD3_ENET1_RGMII_RD3	0x91
+				MX8MQ_IOMUXC_ENET_RD2_ENET1_RGMII_RD2	0x91
+				MX8MQ_IOMUXC_ENET_RD1_ENET1_RGMII_RD1	0x91
+				MX8MQ_IOMUXC_ENET_RD0_ENET1_RGMII_RD0	0x91
+				MX8MQ_IOMUXC_ENET_TXC_ENET1_RGMII_TXC	0x1c
+				MX8MQ_IOMUXC_ENET_RXC_ENET1_RGMII_RXC	0x91
+				MX8MQ_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x91
+				MX8MQ_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x1c
+				MX8MQ_IOMUXC_GPIO1_IO09_GPIO1_IO9	0x19
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_I2C1_SCL_I2C1_SCL			0x4000007f
+				MX8MQ_IOMUXC_I2C1_SDA_I2C1_SDA			0x4000007f
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_I2C2_SCL_I2C2_SCL			0x4000007f
+				MX8MQ_IOMUXC_I2C2_SDA_I2C2_SDA			0x4000007f
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_I2C3_SCL_I2C3_SCL			0x4000007f
+				MX8MQ_IOMUXC_I2C3_SDA_I2C3_SDA			0x4000007f
+			>;
+		};
+
+		pinctrl_i2c4: i2c4grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_I2C4_SCL_I2C4_SCL			0x4000007f
+				MX8MQ_IOMUXC_I2C4_SDA_I2C4_SDA			0x4000007f
+			>;
+		};
+
+		pinctrl_dvfs: dvfsgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO13_GPIO1_IO13	0x16
+			>;
+		};
+
+
+		pinctrl_qspi: qspigrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_NAND_ALE_QSPI_A_SCLK	0x82
+				MX8MQ_IOMUXC_NAND_CE0_B_QSPI_A_SS0_B	0x82
+				MX8MQ_IOMUXC_NAND_DATA00_QSPI_A_DATA0	0x82
+				MX8MQ_IOMUXC_NAND_DATA01_QSPI_A_DATA1	0x82
+				MX8MQ_IOMUXC_NAND_DATA02_QSPI_A_DATA2	0x82
+				MX8MQ_IOMUXC_NAND_DATA03_QSPI_A_DATA3	0x82
+
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_UART1_RXD_UART1_DCE_RX		0x49
+				MX8MQ_IOMUXC_UART1_TXD_UART1_DCE_TX		0x49
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_UART2_RXD_UART2_DCE_RX		0x49
+				MX8MQ_IOMUXC_UART2_TXD_UART2_DCE_TX		0x49
+				MX8MQ_IOMUXC_UART4_RXD_UART2_DCE_CTS_B	0x49
+				MX8MQ_IOMUXC_UART4_TXD_UART2_DCE_RTS_B	0x49
+				MX8MQ_IOMUXC_NAND_CLE_GPIO3_IO5			0x19
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_UART3_TXD_UART3_DCE_TX		0x49
+				MX8MQ_IOMUXC_UART3_RXD_UART3_DCE_RX		0x49
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD1_CLK_USDHC1_CLK			0x83
+				MX8MQ_IOMUXC_SD1_CMD_USDHC1_CMD			0xc3
+				MX8MQ_IOMUXC_SD1_DATA0_USDHC1_DATA0		0xc3
+				MX8MQ_IOMUXC_SD1_DATA1_USDHC1_DATA1		0xc3
+				MX8MQ_IOMUXC_SD1_DATA2_USDHC1_DATA2		0xc3
+				MX8MQ_IOMUXC_SD1_DATA3_USDHC1_DATA3		0xc3
+				MX8MQ_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K 		0x85		/* LPO_IN */
+
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD1_CLK_USDHC1_CLK			0x8d
+				MX8MQ_IOMUXC_SD1_CMD_USDHC1_CMD			0xcd
+				MX8MQ_IOMUXC_SD1_DATA0_USDHC1_DATA0		0xcd
+				MX8MQ_IOMUXC_SD1_DATA1_USDHC1_DATA1		0xcd
+				MX8MQ_IOMUXC_SD1_DATA2_USDHC1_DATA2		0xcd
+				MX8MQ_IOMUXC_SD1_DATA3_USDHC1_DATA3		0xcd
+				MX8MQ_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K 		0x85
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD1_CLK_USDHC1_CLK			0x9f
+				MX8MQ_IOMUXC_SD1_CMD_USDHC1_CMD			0xdf
+				MX8MQ_IOMUXC_SD1_DATA0_USDHC1_DATA0		0xdf
+				MX8MQ_IOMUXC_SD1_DATA1_USDHC1_DATA1		0xdf
+				MX8MQ_IOMUXC_SD1_DATA2_USDHC1_DATA2		0xdf
+				MX8MQ_IOMUXC_SD1_DATA3_USDHC1_DATA3		0xdf
+				MX8MQ_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K 		0x85
+			>;
+		};
+
+		pinctrl_usdhc2_gpio: usdhc2grpgpio {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD2_CD_B_GPIO2_IO12	0x41
+				MX8MQ_IOMUXC_SD2_RESET_B_GPIO2_IO19	0x41
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD2_CLK_USDHC2_CLK			0x83
+				MX8MQ_IOMUXC_SD2_CMD_USDHC2_CMD			0xc3
+				MX8MQ_IOMUXC_SD2_DATA0_USDHC2_DATA0		0xc3
+				MX8MQ_IOMUXC_SD2_DATA1_USDHC2_DATA1		0xc3
+				MX8MQ_IOMUXC_SD2_DATA2_USDHC2_DATA2		0xc3
+				MX8MQ_IOMUXC_SD2_DATA3_USDHC2_DATA3		0xc3
+				MX8MQ_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xc1
+			>;
+		};
+
+		pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD2_CLK_USDHC2_CLK			0x8c
+				MX8MQ_IOMUXC_SD2_CMD_USDHC2_CMD			0xcc
+				MX8MQ_IOMUXC_SD2_DATA0_USDHC2_DATA0		0xcc
+				MX8MQ_IOMUXC_SD2_DATA1_USDHC2_DATA1		0xcc
+				MX8MQ_IOMUXC_SD2_DATA2_USDHC2_DATA2		0xcc
+				MX8MQ_IOMUXC_SD2_DATA3_USDHC2_DATA3		0xcc
+				MX8MQ_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xc1
+			>;
+		};
+
+		pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SD2_CLK_USDHC2_CLK			0x9c
+				MX8MQ_IOMUXC_SD2_CMD_USDHC2_CMD			0xdc
+				MX8MQ_IOMUXC_SD2_DATA0_USDHC2_DATA0		0xdc
+				MX8MQ_IOMUXC_SD2_DATA1_USDHC2_DATA1		0xdc
+				MX8MQ_IOMUXC_SD2_DATA2_USDHC2_DATA2		0xdc
+				MX8MQ_IOMUXC_SD2_DATA3_USDHC2_DATA3		0xdc
+				MX8MQ_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0xcc
+			>;
+		};
+
+	 pinctrl_sai1: sai1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI1_MCLK_SAI1_MCLK                0xd6
+				MX8MQ_IOMUXC_SAI1_TXC_SAI1_TX_BCLK              0xd6
+				MX8MQ_IOMUXC_SAI1_TXFS_SAI1_TX_SYNC             0xd6
+				MX8MQ_IOMUXC_SAI1_RXD0_SAI1_RX_DATA0            0xd6
+				MX8MQ_IOMUXC_SAI1_TXD0_SAI1_TX_DATA0            0xd6
+			 >;
+		};
+
+		pinctrl_sai2: sai2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI2_TXFS_SAI2_TX_SYNC	0xd6
+				MX8MQ_IOMUXC_SAI2_TXC_SAI2_TX_BCLK	0xd6
+				MX8MQ_IOMUXC_SAI2_TXD0_SAI2_TX_DATA0	0xd6
+				MX8MQ_IOMUXC_SAI2_RXD0_SAI2_RX_DATA0    0xd6
+			>;
+		};
+
+		pinctrl_sai3: sai3grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI3_TXC_SAI3_TX_BCLK     0xd6
+				MX8MQ_IOMUXC_SAI3_TXFS_SAI3_TX_SYNC		0xd6
+				MX8MQ_IOMUXC_SAI3_RXD_SAI3_RX_DATA0		0xd6
+				MX8MQ_IOMUXC_SAI3_TXD_SAI3_TX_DATA0		0xd6
+			>;
+		};
+
+		pinctrl_spdif1: spdif1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_TX_SPDIF1_OUT	0xd6
+			>;
+		};
+
+		pinctrl_wdog: wdoggrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B 0xc6
+			>;
+		};
+
+		pinctrl_usbotg0: usbotggrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO10_GPIO1_IO10   0x17059
+			>;
+		};
+	};
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@3 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <3>;
+			at803x,led-act-blind-workaround;
+			at803x,eee-disabled;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <384000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3ab {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <384000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	eeprom: eeprom@50 {
+		compatible = "atmel,24c256";
+		reg = <0x50>;
+		pagesize = <32>;
+		status = "okay";
+	};
+
+	adau1361:adau1361@38 {
+		compatible = "adi,adau1361";
+		reg = <0x38>;
+	};
+
+	a2b24xx: a2b24xx@0x68 {
+		compatible = "adi,a2b24xx";
+		reg = <0x68>;
+	};
+
+};
+
+&i2c3 {
+	clock-frequency = <384000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	adv_bridge: adv7535@3d {
+		compatible = "adi,adv7533";
+		reg = <0x3d>;
+		adi,addr-cec = <0x3b>;
+		adi,dsi-lanes = <4>;
+		status = "disabled";
+
+		port {
+			adv7535_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_adv>;
+			};
+		};
+	};
+};
+
+&uart1 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MQ_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MQ_CLK_25M>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "okay";
+
+	flash0: w25q256@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "sst,w25q256";
+		spi-max-frequency = <100000000>;
+		spi-nor,ddr-quad-read-dummy = <4>;
+		status = "okay";
+	};
+};
+
+&uart2 { /* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	assigned-clocks = <&clk IMX8MQ_CLK_UART2>;
+	assigned-clock-parents = <&clk IMX8MQ_SYS1_PLL_80M>;
+	fsl,uart-has-rtscts;
+	resets = <&modem_reset>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MQ_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MQ_SYS1_PLL_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&ecspi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2>, <&pinctrl_zigbee_ctrl>;
+	fsl,spi-num-chipselects = <1>;
+	spi-max-frequency = <10000000>;
+	status = "okay";
+
+	spidev@0x00 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+		status = "okay";
+	};
+};
+
+&ecspi1 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ecspi1>;
+		fsl,spi-num-chipselects = <1>;
+		cs-gpios = <&gpio1 1 GPIO_ACTIVE_LOW>;
+		spi-max-frequency = <10000000>;
+		status = "okay";
+
+	can0: can@0 {
+		pinctrl-names = "default";
+		compatible = "microchip,mcp2515";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+		clocks = <&clk24M>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <6 0x02>;
+		status = "okay";
+	};
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>, <&pinctrl_wl_reg_on>, <&pinctrl_wl_led>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>, <&pinctrl_wl_reg_on>, <&pinctrl_wl_led>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>, <&pinctrl_wl_reg_on>, <&pinctrl_wl_led>;
+	bus-width = <4>;
+	broken-cd;
+	wifi-host;
+	vmmc-supply = <&reg_usdhc1_vmmc>;
+	status = "okay";
+
+	#address-cells = <0x1>;
+	#size-cells = <0x0>;
+
+	brcmf@0 {
+		reg = <0x1>;
+		compatible = "brcm,bcm4329-fmac";
+		status = "okay";
+	};
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	bus-width = <4>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	extcon = <&extcon_usb0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg0>;
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb3_phy1 {
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&sai1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&clk IMX8MQ_CLK_SAI1>,
+						<&clk IMX8MQ_CLK_SAI1>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <0>, <12288000>;
+	status = "okay";
+};
+
+&sai2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+	assigned-clocks = <&clk IMX8MQ_CLK_SAI2>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MQ_CLK_SAI3>,
+				<&clk IMX8MQ_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <0>, <12288000>;
+	status = "okay";
+};
+
+&sai4 {
+	assigned-clocks = <&clk IMX8MQ_CLK_SAI4>,
+			<&clk IMX8MQ_CLK_SAI4>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <0>, <24576000>;
+	status = "okay";
+};
+
+&spdif1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif1>;
+	assigned-clocks = <&clk IMX8MQ_CLK_SPDIF1>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&spdif2 {
+	assigned-clocks = <&clk IMX8MQ_CLK_SPDIF2>;
+	assigned-clock-parents = <&clk IMX8MQ_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&gpu_pd {
+	power-supply = <&sw1a_reg>;
+};
+
+&vpu_pd {
+	power-supply = <&sw1c_reg>;
+};
+
+&gpu {
+	status = "okay";
+};
+
+&vpu {
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&mu {
+	status = "okay";
+};
+
+&rpmsg{
+	/*
+	 * 64K for one rpmsg instance:
+	 * --0xb8000000~0xb800ffff: pingpong
+	 */
+	vdev-nums = <1>;
+	reg = <0x0 0xb8000000 0x0 0x10000>;
+	status = "okay";
+};
+
+&A53_0 {
+	operating-points = <
+		/* kHz    uV */
+		1500000 1000000
+		1300000 1000000
+		1000000 900000
+		800000  900000
+	>;
+	dc-supply = <&reg_gpio_dvfs>;
+};
+
+&dcss {
+	status = "okay";
+
+	disp-dev = "hdmi_disp";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&mipi_dsi_bridge {
+	port@1 {
+		mipi_dsi_bridge_adv: endpoint {
+			remote-endpoint = <&adv7535_in>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
index f4dcf7ac3c98..8e05f7435c8d 100755
--- a/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq.dtsi
@@ -781,20 +781,10 @@
 		status = "disabled";
 	};
 
-	ecspi1: ecspi@30820000 {
-		compatible = "fsl,imx6ul-ecspi", "fsl,imx51-ecspi";
-		reg = <0x0 0x30820000 0x0 0x10000>;
-		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&clk IMX8MQ_CLK_ECSPI1_ROOT>,
-			 <&clk IMX8MQ_CLK_ECSPI1_ROOT>;
-		clock-names = "ipg", "per";
-		status = "disabled";
-	};
-
 	ecspi1: ecspi@30820000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
-		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
+		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi", "fsl,imx6ul-ecspi";
 		reg = <0x0 0x30820000 0x0 0x10000>;
 		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&clk IMX8MQ_CLK_ECSPI1_ROOT>,
@@ -806,7 +796,7 @@
 	ecspi2: ecspi@30830000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
-		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
+		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi", "fsl,imx6ul-ecspi";
 		reg = <0x0 0x30830000 0x0 0x10000>;
 		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&clk IMX8MQ_CLK_ECSPI2_ROOT>,
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 211e517d6ac2..75a139c2bda4 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -1,3 +1,5 @@
+CONFIG_LOCALVERSION="-imx_4.14.62_1.0.0_beta"
+CONFIG_COMPILE_TEST=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
 CONFIG_AUDIT=y
@@ -155,6 +157,7 @@ CONFIG_LLC2=y
 CONFIG_BPF_JIT=y
 CONFIG_CAN=y
 CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_MCP251X=y
 CONFIG_BT=y
 CONFIG_BT_RFCOMM=y
 CONFIG_BT_RFCOMM_TTY=y
@@ -212,6 +215,7 @@ CONFIG_SENSORS_FXOS8700=y
 CONFIG_SENSORS_FXAS2100X=y
 CONFIG_SRAM=y
 CONFIG_EEPROM_AT25=m
+CONFIG_EEPROM_AT24=y
 # CONFIG_SCSI_PROC_FS is not set
 CONFIG_BLK_DEV_SD=y
 CONFIG_SCSI_SAS_ATA=y
@@ -342,6 +346,7 @@ CONFIG_XEN_I2C_BACKEND=y
 CONFIG_SPI=y
 CONFIG_SPI_BCM2835=m
 CONFIG_SPI_BCM2835AUX=m
+CONFIG_SPI_BITBANG=y
 CONFIG_SPI_FSL_LPSPI=y
 CONFIG_SPI_IMX=y
 CONFIG_SPI_MESON_SPICC=m
@@ -517,6 +522,7 @@ CONFIG_SND_SOC_IMX_AK5558=y
 CONFIG_SND_SOC_IMX_AK4497=y
 CONFIG_SND_SOC_IMX_WM8960=y
 CONFIG_SND_SOC_IMX_WM8524=y
+CONFIG_SND_SOC_IMX_ADAU1361=y
 CONFIG_SND_SOC_IMX_CS42888=y
 CONFIG_SND_SOC_IMX_WM8962=y
 CONFIG_SND_SOC_IMX_MICFIL=y
@@ -559,15 +565,44 @@ CONFIG_USB_RENESAS_USBHS=m
 CONFIG_USB_ACM=m
 CONFIG_USB_STORAGE=y
 CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+# CONFIG_USB_DWC3_GADGET is not set
+CONFIG_USB_DWC3_DUAL_ROLE=y
+#
+# Platform Glue Driver Support
+#
+CONFIG_USB_DWC3_OMAP=y
+CONFIG_USB_DWC3_EXYNOS=y
+CONFIG_USB_DWC3_PCI=y
+CONFIG_USB_DWC3_KEYSTONE=y
+CONFIG_USB_DWC3_OF_SIMPLE=y
+CONFIG_USB_DWC3_ST=y
 CONFIG_USB_DWC2=y
+# CONFIG_USB_DWC2_HOST is not set
+#
+# Gadget/Dual-role mode requires USB Gadget support to be enabled
+#
+# CONFIG_USB_DWC2_PERIPHERAL is not set
+CONFIG_USB_DWC2_DUAL_ROLE=y
+# CONFIG_USB_DWC2_PCI is not set
+# CONFIG_USB_DWC2_DEBUG is not set
+# CONFIG_USB_DWC2_TRACK_MISSED_SOFS is not set
 CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_OF=y
+CONFIG_USB_CHIPIDEA_PCI=y
 CONFIG_USB_CHIPIDEA_UDC=y
 CONFIG_USB_CHIPIDEA_HOST=y
 CONFIG_USB_ISP1760=y
+CONFIG_USB_ISP1760_HCD=y
 CONFIG_USB_ISP1760_HOST_ROLE=y
+# CONFIG_USB_ISP1760_GADGET_ROLE is not set
+# CONFIG_USB_ISP1760_DUAL_ROLE is not set
 CONFIG_USB_CDNS3=y
+CONFIG_USB_ISP1760_HOST_ROLE=y
 CONFIG_USB_CDNS3_GADGET=y
 CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CP210X=y
 CONFIG_USB_TEST=m
 CONFIG_USB_EHSET_TEST_FIXTURE=y
 CONFIG_USB_HSIC_USB3503=y
@@ -576,8 +611,80 @@ CONFIG_USB_GPIO_VBUS=y
 CONFIG_USB_QCOM_8X16_PHY=y
 CONFIG_USB_MXS_PHY=y
 CONFIG_USB_ULPI=y
+CONFIG_USB_ULPI_VIEWPORT=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
 CONFIG_USB_GADGET=y
 CONFIG_USB_RENESAS_USBHS_UDC=m
+# CONFIG_USB_RENESAS_USB3 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+CONFIG_USB_SNP_CORE=y
+CONFIG_USB_SNP_UDC_PLAT=y
+# CONFIG_USB_M66592 is not set
+CONFIG_USB_BDC_UDC=y
+#
+# Platform Support
+#
+CONFIG_USB_BDC_PCI=y
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_F_SS_LB=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_U_AUDIO=y
+CONFIG_USB_F_SERIAL=y
+CONFIG_USB_F_OBEX=y
+CONFIG_USB_F_NCM=y
+CONFIG_USB_F_ECM=y
+CONFIG_USB_F_EEM=y
+CONFIG_USB_F_SUBSET=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_FS=y
+CONFIG_USB_F_UAC1=y
+CONFIG_USB_F_UAC2=y
+CONFIG_USB_F_MIDI=y
+CONFIG_USB_F_HID=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_FSL_UTP=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+# CONFIG_USB_CONFIGFS_F_UVC is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
 CONFIG_USB_CONFIGFS=y
 CONFIG_USB_CONFIGFS_SERIAL=y
 CONFIG_USB_CONFIGFS_ACM=y
@@ -596,14 +703,34 @@ CONFIG_USB_CONFIGFS_F_UAC2=y
 CONFIG_USB_CONFIGFS_F_MIDI=y
 CONFIG_USB_CONFIGFS_F_HID=y
 CONFIG_USB_ZERO=m
+# CONFIG_USB_ZERO_HNPTEST is not set
 CONFIG_USB_AUDIO=m
 CONFIG_GADGET_UAC1=y
+# CONFIG_GADGET_UAC1_LEGACY is not set
 CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
 CONFIG_USB_ETH_EEM=y
 CONFIG_USB_G_NCM=m
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
 CONFIG_USB_MASS_STORAGE=m
 CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
 CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+#
+# USB Power Delivery and Type-C drivers
+#
+CONFIG_TYPEC=y
+# CONFIG_TYPEC_UCSI is not set
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
 CONFIG_MMC=y
 CONFIG_MMC_BLOCK_MINORS=32
 CONFIG_MMC_ARMMMCI=y
@@ -709,6 +836,7 @@ CONFIG_ROCKCHIP_PM_DOMAINS=y
 CONFIG_ARCH_TEGRA_132_SOC=y
 CONFIG_ARCH_TEGRA_210_SOC=y
 CONFIG_ARCH_TEGRA_186_SOC=y
+CONFIG_EXTCON_USB_GPIO=y
 CONFIG_EXTCON_PTN5150=y
 CONFIG_IIO=y
 CONFIG_EXYNOS_ADC=y
@@ -820,3 +948,8 @@ CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_CHACHA20_NEON=m
 CONFIG_CRYPTO_AES_ARM64_BS=m
+#
+# CAN SPI interfaces
+#
+CONFIG_CAN_MCP251X=y
+arrow.cfg
diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index 05fa891dcd43..babc509a0ccf 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -150,6 +150,14 @@ config EXTCON_USB_GPIO
 	  Say Y here to enable GPIO based USB cable detection extcon support.
 	  Used typically if GPIO is used for USB ID pin detection.
 
+config EXTCON_USB_VBUS_GPIO
+	tristate "USB GPIO vbus extcon support"
+	depends on GPIOLIB || COMPILE_TEST
+	help
+	  Say Y here to enable GPIO based USB cable detection and setting
+	  of vbus pin  extcon support.Used typically if GPIO is used for USB
+	  ID pin detection and Vbus pin set.
+
 config EXTCON_USBC_CROS_EC
 	tristate "ChromeOS Embedded Controller EXTCON support"
 	depends on MFD_CROS_EC
diff --git a/drivers/extcon/Makefile b/drivers/extcon/Makefile
index cc36ee05d5bd..0bbd01ef6ec8 100644
--- a/drivers/extcon/Makefile
+++ b/drivers/extcon/Makefile
@@ -21,5 +21,6 @@ obj-$(CONFIG_EXTCON_QCOM_SPMI_MISC) += extcon-qcom-spmi-misc.o
 obj-$(CONFIG_EXTCON_RT8973A)	+= extcon-rt8973a.o
 obj-$(CONFIG_EXTCON_SM5502)	+= extcon-sm5502.o
 obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
+obj-$(CONFIG_EXTCON_USB_VBUS_GPIO)   += extcon-usb-gpio-vbus.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
 obj-$(CONFIG_EXTCON_PTN5150)	+= extcon-ptn5150.o
diff --git a/drivers/extcon/extcon-usb-gpio-vbus.c b/drivers/extcon/extcon-usb-gpio-vbus.c
new file mode 100644
index 000000000000..4a154f15b717
--- /dev/null
+++ b/drivers/extcon/extcon-usb-gpio-vbus.c
@@ -0,0 +1,280 @@
+/**
+ * drivers/extcon/extcon-usb-gpio.c - USB GPIO extcon driver
+ *
+ * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com
+ * Author: Roger Quadros <rogerq@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/extcon.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/pinctrl/consumer.h>
+
+#define USB_GPIO_DEBOUNCE_MS	20	/* ms */
+
+struct usb_extcon_info {
+	struct device *dev;
+	struct extcon_dev *edev;
+
+	struct gpio_desc *id_gpiod;
+	struct gpio_desc *vbus_gpiod;
+	int id_irq;
+	int vbus_irq;
+
+	unsigned long debounce_jiffies;
+	struct delayed_work wq_detcable;
+};
+
+static const unsigned int usb_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_NONE,
+};
+
+/*
+ * "USB" = VBUS and "USB-HOST" = !ID, so we have:
+ * Both "USB" and "USB-HOST" can't be set as active at the
+ * same time so if "USB-HOST" is active (i.e. ID is 0)  we keep "USB" inactive
+ * even if VBUS is on.
+ *
+ *  State              |    ID   |   VBUS
+ * ----------------------------------------
+ *  [1] USB            |    H    |    H
+ *  [2] none           |    H    |    L
+ *  [3] USB-HOST       |    L    |    H
+ *  [4] USB-HOST       |    L    |    L
+ *
+ * In case we have only one of these signals:
+ * - VBUS only - we want to distinguish between [1] and [2], so ID is always 1.
+ * - ID only - we want to distinguish between [1] and [4], so VBUS = ID.
+*/
+static void usb_extcon_detect_cable_set_vbus(struct work_struct *work)
+{
+	int id, vbus;
+	struct usb_extcon_info *info = container_of(to_delayed_work(work),
+						    struct usb_extcon_info,
+						    wq_detcable);
+
+	/* check ID and VBUS and update cable state */
+	id = info->id_gpiod ?
+		gpiod_get_value_cansleep(info->id_gpiod) : 1;
+	vbus = info->vbus_gpiod ?
+		gpiod_get_value_cansleep(info->vbus_gpiod) : id;
+
+	/* at first we clean states which are no longer active */
+	if (id)
+	{
+		extcon_set_state_sync(info->edev, EXTCON_USB_HOST, false);
+		gpiod_set_value_cansleep(info->vbus_gpiod, 0);
+		printk("id  = %d and vbus = %d \n", gpiod_get_value_cansleep(info->id_gpiod), gpiod_get_value_cansleep(info->vbus_gpiod));
+	}
+	if (!id)
+	{
+		extcon_set_state_sync(info->edev, EXTCON_USB_HOST, true);
+		gpiod_set_value_cansleep(info->vbus_gpiod, 1);
+		printk("id  = %d and vbus = %d \n", gpiod_get_value_cansleep(info->id_gpiod), gpiod_get_value_cansleep(info->vbus_gpiod));
+	}
+}
+
+static irqreturn_t usb_irq_handler(int irq, void *dev_id)
+{
+	struct usb_extcon_info *info = dev_id;
+
+	queue_delayed_work(system_power_efficient_wq, &info->wq_detcable,
+			   info->debounce_jiffies);
+
+	return IRQ_HANDLED;
+}
+
+static int usb_extcon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct usb_extcon_info *info;
+	int ret;
+
+	if (!np)
+		return -EINVAL;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->dev = dev;
+	info->id_gpiod = devm_gpiod_get_optional(&pdev->dev, "id", GPIOD_IN);
+	info->vbus_gpiod = devm_gpiod_get_optional(&pdev->dev, "vbus",
+						   GPIOD_OUT_LOW);
+
+	if (!info->id_gpiod && !info->vbus_gpiod) {
+		dev_err(dev, "failed to get gpios\n");
+		return -ENODEV;
+	}
+
+	if (IS_ERR(info->id_gpiod))
+		return PTR_ERR(info->id_gpiod);
+
+	if (IS_ERR(info->vbus_gpiod))
+		return PTR_ERR(info->vbus_gpiod);
+
+	info->edev = devm_extcon_dev_allocate(dev, usb_extcon_cable);
+	if (IS_ERR(info->edev)) {
+		dev_err(dev, "failed to allocate extcon device\n");
+		return -ENOMEM;
+	}
+
+	ret = devm_extcon_dev_register(dev, info->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to register extcon device\n");
+		return ret;
+	}
+
+	if (info->id_gpiod)
+		ret = gpiod_set_debounce(info->id_gpiod,
+					 USB_GPIO_DEBOUNCE_MS * 1000);
+	if (!ret && info->vbus_gpiod)
+		ret = gpiod_set_debounce(info->vbus_gpiod,
+					 USB_GPIO_DEBOUNCE_MS * 1000);
+
+	if (ret < 0)
+		info->debounce_jiffies = msecs_to_jiffies(USB_GPIO_DEBOUNCE_MS);
+
+	INIT_DELAYED_WORK(&info->wq_detcable, usb_extcon_detect_cable_set_vbus);
+
+	if (info->id_gpiod) {
+		info->id_irq = gpiod_to_irq(info->id_gpiod);
+		if (info->id_irq < 0) {
+			dev_err(dev, "failed to get ID IRQ\n");
+			return info->id_irq;
+		}
+
+		ret = devm_request_threaded_irq(dev, info->id_irq, NULL,
+						usb_irq_handler,
+						IRQF_TRIGGER_RISING |
+						IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+						pdev->name, info);
+		if (ret < 0) {
+			dev_err(dev, "failed to request handler for ID IRQ\n");
+			return ret;
+		}
+	}
+
+	platform_set_drvdata(pdev, info);
+	device_set_wakeup_capable(&pdev->dev, true);
+
+	/* Perform initial detection */
+	usb_extcon_detect_cable_set_vbus(&info->wq_detcable.work);
+
+	return 0;
+}
+
+static int usb_extcon_remove(struct platform_device *pdev)
+{
+	struct usb_extcon_info *info = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&info->wq_detcable);
+	device_init_wakeup(&pdev->dev, false);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int usb_extcon_suspend(struct device *dev)
+{
+	struct usb_extcon_info *info = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (device_may_wakeup(dev)) {
+		if (info->id_gpiod) {
+			ret = enable_irq_wake(info->id_irq);
+			if (ret)
+				return ret;
+		}
+	}
+
+	/*
+	 * We don't want to process any IRQs after this point
+	 * as GPIOs used behind I2C subsystem might not be
+	 * accessible until resume completes. So disable IRQ.
+	 */
+	if (info->id_gpiod)
+		disable_irq(info->id_irq);
+	if (!device_may_wakeup(dev))
+		pinctrl_pm_select_sleep_state(dev);
+
+	return ret;
+}
+
+static int usb_extcon_resume(struct device *dev)
+{
+	struct usb_extcon_info *info = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (!device_may_wakeup(dev))
+		pinctrl_pm_select_default_state(dev);
+
+	if (device_may_wakeup(dev)) {
+		if (info->id_gpiod) {
+			ret = disable_irq_wake(info->id_irq);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (info->id_gpiod)
+		enable_irq(info->id_irq);
+	queue_delayed_work(system_power_efficient_wq,
+			   &info->wq_detcable, 0);
+
+	return ret;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(usb_extcon_pm_ops,
+			 usb_extcon_suspend, usb_extcon_resume);
+
+static const struct of_device_id usb_extcon_dt_match[] = {
+	{ .compatible = "linux,extcon-usb-gpio-vbus", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, usb_extcon_dt_match);
+
+static const struct platform_device_id usb_extcon_platform_ids[] = {
+	{ .name = "extcon-usb-gpio-vbus", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, usb_extcon_platform_ids);
+
+static struct platform_driver usb_extcon_driver = {
+	.probe		= usb_extcon_probe,
+	.remove		= usb_extcon_remove,
+	.driver		= {
+		.name	= "extcon-usb-gpio-vbus",
+		.pm	= &usb_extcon_pm_ops,
+		.of_match_table = usb_extcon_dt_match,
+	},
+	.id_table = usb_extcon_platform_ids,
+};
+
+module_platform_driver(usb_extcon_driver);
+
+MODULE_AUTHOR("Roger Quadros <rogerq@ti.com>");
+MODULE_DESCRIPTION("USB GPIO extcon driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index 37317ceee0af..ad822731e0b7 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -36,10 +36,17 @@
 #include <soc/imx8/sc/sci.h>
 #include <video/videomode.h>
 
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
 #include "imx-drm.h"
 
 #define DRIVER_NAME "nwl_dsi-imx"
 
+#define IMX8HMI_MIPI_DSI_SW_GPIO		68
+#define MEZANINE_EN				1
+#define MEZANINE_DIS				0
+
 /* 8MQ SRC specific registers */
 #define SRC_MIPIPHY_RCR				0x28
 #define RESET_BYTE_N				BIT(1)
@@ -60,6 +67,16 @@
 #define CLK_BYPASS	"bypass"
 #define CLK_PHYREF	"phy_ref"
 
+/*
+
+Default dual display adjustment freq disabled
+if set true 10 inch touch support enable, to do
+so remove Dual_disp from dts
+
+*/
+
+static bool set_dual_disp_best_match = true;
+
 /* Possible valid PHY reference clock rates*/
 u32 phyref_rates[] = {
 	24000000,
@@ -123,6 +140,7 @@ struct devtype {
 
 static int imx8qm_dsi_poweron(struct imx_mipi_dsi *dsi);
 static void imx8qm_dsi_poweroff(struct imx_mipi_dsi *dsi);
+
 static struct devtype imx8qm_dev = {
 	.poweron = &imx8qm_dsi_poweron,
 	.poweroff = &imx8qm_dsi_poweroff,
@@ -491,7 +509,7 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 		mixel_phy_mipi_set_phy_speed(dsi->phy,
 			bit_clk,
 			dsi->phyref_rate,
-			false);
+			set_dual_disp_best_match);
 		dsi->bit_clk = bit_clk;
 	}
 
@@ -592,7 +610,7 @@ static int imx_nwl_try_phy_speed(struct imx_mipi_dsi *dsi,
 		ret = mixel_phy_mipi_set_phy_speed(dsi->phy,
 			bit_clk,
 			dsi->phyref_rate,
-			false);
+			set_dual_disp_best_match);
 		/* Pick the first non-failing rate */
 		if (!ret)
 			break;
@@ -921,6 +939,8 @@ static int imx_nwl_dsi_probe(struct platform_device *pdev)
 	struct device_node *remote_node, *endpoint;
 	int remote_ports = 0;
 	struct imx_mipi_dsi *dsi;
+	uint8_t mipi_sw_en_status = MEZANINE_DIS;
+	unsigned int dsi_sw_sel = IMX8HMI_MIPI_DSI_SW_GPIO ;
 	int ret = 0;
 
 	if (!np)
@@ -964,6 +984,39 @@ static int imx_nwl_dsi_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(dev);
 
+	if (of_property_read_bool(dev->of_node, "Dual_disp")) {
+		set_dual_disp_best_match = false;
+		dev_info(dev, "Dual-display support enabled");
+	}
+	else {
+		dev_info(dev, "Dual-display support disabled");
+	}
+
+	/* Default status of Mezzanine DSI : Disabled */
+	if (of_property_read_bool(dev->of_node, "Mezzanine_DSI")) {
+		mipi_sw_en_status = MEZANINE_EN;
+		printk("Mezzanine DSI enabled \n");
+	}
+	else {
+		printk("Mezzanine DSI disabled \n");
+	}
+
+	printk("dsi_sw_sel gpio val %d \n",dsi_sw_sel);
+	if (!gpio_is_valid(dsi_sw_sel)) {
+		printk("invalid dsi_sw_sel gpio, cannot switch mipi sw\n");
+		return -ENODEV;
+	}
+
+	ret = gpio_request(dsi_sw_sel, "mipi_switch");
+	if (ret < 0) {
+		printk("request dsi_sw_sel failed, cannot switch mipi sw: %d\n",
+			ret);
+		return ret;
+	}
+	gpio_direction_output(dsi_sw_sel, mipi_sw_en_status);
+	gpio_set_value(dsi_sw_sel, mipi_sw_en_status);
+
+
 	if (of_property_read_bool(dev->of_node, "as_bridge")) {
 		ret = imx_nwl_dsi_parse_of(dev, true);
 		if (ret)
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 86b29ffa991e..53c0fb99e97c 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -23,6 +23,7 @@
 #include <linux/of_platform.h>
 #include <linux/spi/flash.h>
 #include <linux/mtd/spi-nor.h>
+#include <linux/gpio.h>
 
 /* Define max times to check status register before we give up. */
 
@@ -41,6 +42,9 @@
 #define SPI_NOR_MAX_ID_LEN	6
 #define SPI_NOR_MAX_ADDR_WIDTH	4
 
+#define OUT                                                    0
+#define IMX8THOR_NOR_CS_SW_GPIO                               64
+
 struct flash_info {
 	char		*name;
 
@@ -1184,7 +1188,7 @@ static const struct flash_info spi_nor_ids[] = {
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
-	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "w25q256", INFO(0xef6019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "w25m512jv", INFO(0xef7119, 0, 64 * 1024, 1024,
 			SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_DUAL_READ) },
 
@@ -2710,6 +2714,25 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	int ret;
 	int i;
 
+	printk("nor cs gpio val %d \n",IMX8THOR_NOR_CS_SW_GPIO);
+	if (!gpio_is_valid(IMX8THOR_NOR_CS_SW_GPIO)) {
+		printk("invalid nor cs gpio, cannot switch mipi sw\n");
+		return -ENODEV;
+	}
+
+	ret = gpio_request(IMX8THOR_NOR_CS_SW_GPIO, "nor_cs");
+	if (ret < 0) {
+		printk("request nor cs failed, cannot nor cs sw: %d\n",ret);
+		return ret;
+	}
+
+	gpio_direction_output(IMX8THOR_NOR_CS_SW_GPIO, OUT);
+	gpio_set_value(IMX8THOR_NOR_CS_SW_GPIO, 0);
+
+	printk("nor cs gpio low, nor cs sw\n");
+	printk("spi nor name %s\n",name);
+	printk("%s %d\n",__func__,__LINE__);
+
 	ret = spi_nor_check(nor);
 	if (ret)
 		return ret;
diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c
index f3f05fea8e1f..91c66247ffca 100644
--- a/drivers/net/can/spi/mcp251x.c
+++ b/drivers/net/can/spi/mcp251x.c
@@ -640,6 +640,7 @@ static int mcp251x_hw_reset(struct spi_device *spi)
 
 	/* Wait for oscillator startup timer after reset */
 	mdelay(MCP251X_OST_DELAY_MS);
+	mdelay(MCP251X_OST_DELAY_MS);
 	
 	reg = mcp251x_read_reg(spi, CANSTAT);
 	if ((reg & CANCTRL_REQOP_MASK) != CANCTRL_REQOP_CONF)
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
index ad15b4ba66af..dbe2c5a90f5f 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
@@ -1116,6 +1116,7 @@ static const struct sdio_device_id brcmf_sdmmc_ids[] = {
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43455),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4354),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4356),
+	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4359),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_4373),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_43012),
 	{ /* end: all zeroes */ }
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 32c797f5fb0f..767bf5d345a1 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -239,6 +239,19 @@ struct parsed_vndr_ies {
 	struct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];
 };
 
+#define WL_INTERFACE_MAC_DONT_USE	0x0
+#define WL_INTERFACE_MAC_USE		0x2
+
+#define WL_INTERFACE_CREATE_STA		0x0
+#define WL_INTERFACE_CREATE_AP		0x1
+
+struct wl_interface_create {
+	u16	ver;
+	u32	flags;
+	u8	mac_addr[ETH_ALEN];
+	u8	pad[13];
+};
+
 static u8 nl80211_band_to_fwil(enum nl80211_band band)
 {
 	switch (band) {
@@ -547,6 +560,42 @@ static int brcmf_get_first_free_bsscfgidx(struct brcmf_pub *drvr)
 	return -ENOMEM;
 }
 
+static void brcmf_set_sta_iface_macaddr(struct brcmf_if *ifp,
+					struct wl_interface_create *iface)
+{
+	u8 mac_idx = ifp->drvr->sta_mac_idx;
+
+	/* set difference MAC address with locally administered bit */
+	iface->flags |= WL_INTERFACE_MAC_USE;
+	memcpy(iface->mac_addr, ifp->mac_addr, ETH_ALEN);
+	iface->mac_addr[0] |= 0x02;
+	iface->mac_addr[3] ^= mac_idx ? 0xC0 : 0xA0;
+	mac_idx++;
+	mac_idx = mac_idx % 2;
+	ifp->drvr->sta_mac_idx = mac_idx;
+}
+
+static int brcmf_cfg80211_request_sta_if(struct brcmf_if *ifp, u8 *macaddr)
+{
+	struct wl_interface_create iface;
+	int err;
+
+	memset(&iface, 0, sizeof(iface));
+
+	iface.ver = 0;
+	iface.flags = WL_INTERFACE_CREATE_STA;
+	if (!is_zero_ether_addr(macaddr)) {
+		/* set MAC address in cfg80211 params */
+		memcpy(iface.mac_addr, macaddr, ETH_ALEN);
+	} else {
+		brcmf_set_sta_iface_macaddr(ifp, &iface);
+	}
+
+	err = brcmf_fil_iovar_data_get(ifp, "interface_create", &iface,
+				       sizeof(iface));
+	return err;
+}
+
 static int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)
 {
 	struct brcmf_mbss_ssid_le mbss_ssid_le;
@@ -571,33 +620,40 @@ static int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)
 }
 
 /**
- * brcmf_ap_add_vif() - create a new AP virtual interface for multiple BSS
+ * brcmf_ap_add_vif() - create a new AP or STA virtual interface
  *
  * @wiphy: wiphy device of new interface.
  * @name: name of the new interface.
- * @params: contains mac address for AP device.
+ * @params: contains mac address for AP or STA device.
  */
 static
-struct wireless_dev *brcmf_ap_add_vif(struct wiphy *wiphy, const char *name,
-				      struct vif_params *params)
+struct wireless_dev *brcmf_apsta_add_vif(struct wiphy *wiphy, const char *name,
+					 struct vif_params *params,
+					 enum nl80211_iftype type)
 {
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
 	struct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));
 	struct brcmf_cfg80211_vif *vif;
 	int err;
 
+	if (type != NL80211_IFTYPE_STATION && type != NL80211_IFTYPE_AP)
+		return ERR_PTR(-EINVAL);
+
 	if (brcmf_cfg80211_vif_event_armed(cfg))
 		return ERR_PTR(-EBUSY);
 
 	brcmf_dbg(INFO, "Adding vif \"%s\"\n", name);
 
-	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP);
+	vif = brcmf_alloc_vif(cfg, type);
 	if (IS_ERR(vif))
 		return (struct wireless_dev *)vif;
 
 	brcmf_cfg80211_arm_vif_event(cfg, vif);
 
-	err = brcmf_cfg80211_request_ap_if(ifp);
+	if (type == NL80211_IFTYPE_STATION)
+		err = brcmf_cfg80211_request_sta_if(ifp, params->macaddr);
+	else
+		err = brcmf_cfg80211_request_ap_if(ifp);
 	if (err) {
 		brcmf_cfg80211_arm_vif_event(cfg, NULL);
 		goto fail;
@@ -666,14 +722,14 @@ static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
 	}
 	switch (type) {
 	case NL80211_IFTYPE_ADHOC:
-	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_AP_VLAN:
 	case NL80211_IFTYPE_WDS:
 	case NL80211_IFTYPE_MONITOR:
 	case NL80211_IFTYPE_MESH_POINT:
 		return ERR_PTR(-EOPNOTSUPP);
+	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_AP:
-		wdev = brcmf_ap_add_vif(wiphy, name, params);
+		wdev = brcmf_apsta_add_vif(wiphy, name, params, type);
 		break;
 	case NL80211_IFTYPE_P2P_CLIENT:
 	case NL80211_IFTYPE_P2P_GO:
@@ -791,8 +847,8 @@ s32 brcmf_notify_escan_complete(struct brcmf_cfg80211_info *cfg,
 	return err;
 }
 
-static int brcmf_cfg80211_del_ap_iface(struct wiphy *wiphy,
-				       struct wireless_dev *wdev)
+static int brcmf_cfg80211_del_apsta_iface(struct wiphy *wiphy,
+					  struct wireless_dev *wdev)
 {
 	struct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);
 	struct net_device *ndev = wdev->netdev;
@@ -848,14 +904,14 @@ int brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)
 
 	switch (wdev->iftype) {
 	case NL80211_IFTYPE_ADHOC:
-	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_AP_VLAN:
 	case NL80211_IFTYPE_WDS:
 	case NL80211_IFTYPE_MONITOR:
 	case NL80211_IFTYPE_MESH_POINT:
 		return -EOPNOTSUPP;
+	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_AP:
-		return brcmf_cfg80211_del_ap_iface(wiphy, wdev);
+		return brcmf_cfg80211_del_apsta_iface(wiphy, wdev);
 	case NL80211_IFTYPE_P2P_CLIENT:
 	case NL80211_IFTYPE_P2P_GO:
 	case NL80211_IFTYPE_P2P_DEVICE:
@@ -1367,6 +1423,31 @@ static int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)
 	return err;
 }
 
+static int brcmf_set_sae_password(struct brcmf_if *ifp, const u8 *pwd_data,
+				  u16 pwd_len)
+{
+	struct brcmf_wsec_sae_pwd_le sae_pwd;
+	int err;
+
+	if (pwd_len > BRCMF_WSEC_MAX_SAE_PASSWORD_LEN) {
+		brcmf_err("sae_password must be less than %d\n",
+			  BRCMF_WSEC_MAX_SAE_PASSWORD_LEN);
+		return -EINVAL;
+	}
+
+	sae_pwd.key_len = cpu_to_le16(pwd_len);
+	memcpy(sae_pwd.key, pwd_data, pwd_len);
+
+	err = brcmf_fil_iovar_data_set(ifp, "sae_password", &sae_pwd,
+				       sizeof(sae_pwd));
+	if (err < 0)
+		brcmf_err("failed to set SAE password in firmware (len=%u)\n",
+			  pwd_len);
+
+	return err;
+}
+
+
 static void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason)
 {
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);
@@ -1581,6 +1662,8 @@ static s32 brcmf_set_wpa_version(struct net_device *ndev,
 		val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
 	else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)
 		val = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;
+	else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_3)
+		val = WPA3_AUTH_SAE_PSK;
 	else
 		val = WPA_AUTH_DISABLED;
 	brcmf_dbg(CONN, "setting wpa_auth to 0x%0x\n", val);
@@ -1611,6 +1694,10 @@ static s32 brcmf_set_auth_type(struct net_device *ndev,
 		val = 1;
 		brcmf_dbg(CONN, "shared key\n");
 		break;
+	case NL80211_AUTHTYPE_SAE:
+		val = 3;
+		brcmf_dbg(CONN, "SAE authentication\n");
+		break;
 	default:
 		val = 2;
 		brcmf_dbg(CONN, "automatic, auth type (%d)\n", sme->auth_type);
@@ -1718,6 +1805,7 @@ brcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)
 	u16 count;
 
 	profile->use_fwsup = BRCMF_PROFILE_FWSUP_NONE;
+	profile->is_ft = false;
 
 	if (!sme->crypto.n_akm_suites)
 		return 0;
@@ -1762,21 +1850,50 @@ brcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)
 			break;
 		case WLAN_AKM_SUITE_FT_8021X:
 			val = WPA2_AUTH_UNSPECIFIED | WPA2_AUTH_FT;
+			profile->is_ft = true;
 			if (sme->want_1x)
 				profile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;
 			break;
 		case WLAN_AKM_SUITE_FT_PSK:
 			val = WPA2_AUTH_PSK | WPA2_AUTH_FT;
+			profile->is_ft = true;
+			break;
+		default:
+			brcmf_err("invalid cipher group (%d)\n",
+				  sme->crypto.cipher_group);
+			return -EINVAL;
+		}
+	} else if (val & WPA3_AUTH_SAE_PSK) {
+		switch (sme->crypto.akm_suites[0]) {
+		case WLAN_AKM_SUITE_SAE:
+			val = WPA3_AUTH_SAE_PSK;
+			profile->use_fwsup = BRCMF_PROFILE_FWSUP_SAE;
 			break;
 		default:
 			brcmf_err("invalid cipher group (%d)\n",
 				  sme->crypto.cipher_group);
 			return -EINVAL;
 		}
+
 	}
 
 	if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X)
 		brcmf_dbg(INFO, "using 1X offload\n");
+	else if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_SAE){
+		/* clean up user-space RSNE */
+		if (brcmf_fil_iovar_data_set(ifp, "wpaie", NULL, 0)) {
+			brcmf_err("failed to clean up user-space RSNE\n");
+			goto done;
+		}
+		err = brcmf_set_sae_password(ifp, sme->crypto.sae_pwd,
+					     sme->crypto.sae_pwd_len);
+		if (!err && sme->crypto.psk)
+			err = brcmf_set_pmk(ifp, sme->crypto.psk,
+					    BRCMF_WSEC_MAX_PSK_LEN);
+		brcmf_dbg(INFO, "using SAE offload\n");
+	}
+	if (err)
+		goto done;
 
 	if (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))
 		goto skip_mfp_config;
@@ -1820,7 +1937,9 @@ brcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)
 		return err;
 	}
 
-	return err;
+done:
+        brcmf_dbg(TRACE, "Exit\n");
+        return err;
 }
 
 static s32
@@ -1842,7 +1961,8 @@ brcmf_set_sharedkey(struct net_device *ndev,
 	brcmf_dbg(CONN, "wpa_versions 0x%x cipher_pairwise 0x%x\n",
 		  sec->wpa_versions, sec->cipher_pairwise);
 
-	if (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
+	if (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2 |
+				 NL80211_WPA_VERSION_3))
 		return 0;
 
 	if (!(sec->cipher_pairwise &
@@ -2047,7 +2167,9 @@ brcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 		goto done;
 	}
 
-	if (sme->crypto.psk) {
+	if (sme->crypto.psk &&
+	    profile->use_fwsup != BRCMF_PROFILE_FWSUP_SAE) {
+
 		if (WARN_ON(profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE)) {
 			err = -EINVAL;
 			goto done;
@@ -2825,7 +2947,8 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
 		goto done;
 	}
 
-	pm = enabled ? PM_FAST : PM_OFF;
+	pm = enabled ? ifp->drvr->settings->default_pm : PM_OFF;
+
 	/* Do not enable the power save after assoc if it is a p2p interface */
 	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
 		brcmf_dbg(INFO, "Do not enable power save for P2P clients\n");
@@ -2863,7 +2986,7 @@ static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info *cfg,
 
 	if (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {
 		brcmf_err("Bss info is larger than buffer. Discarding\n");
-		return 0;
+		return -EINVAL;
 	}
 
 	if (!bi->ctl_ch) {
@@ -3820,6 +3943,7 @@ static s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,
 		brcmf_set_mpc(ifp, 1);
 
 	} else {
+		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))
 		/* Configure WOWL parameters */
 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))
 			brcmf_configure_wowl(cfg, ifp, wowl);
@@ -4361,6 +4485,11 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,
 		mgmt_ie_len = &saved_ie->assoc_req_ie_len;
 		mgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);
 		break;
+	case BRCMF_VNDR_IE_ASSOCRSP_FLAG:
+		mgmt_ie_buf = saved_ie->assoc_res_ie;
+		mgmt_ie_len = &saved_ie->assoc_res_ie_len;
+		mgmt_ie_buf_len = sizeof(saved_ie->assoc_res_ie);
+		break;
 	default:
 		err = -EPERM;
 		brcmf_err("not suitable type\n");
@@ -4510,6 +4639,15 @@ brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,
 	else
 		brcmf_dbg(TRACE, "Applied Vndr IEs for Probe Resp\n");
 
+	/* Set Assoc Response IEs to FW */
+	err = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_ASSOCRSP_FLAG,
+				    beacon->assocresp_ies,
+				    beacon->assocresp_ies_len);
+	if (err)
+		brcmf_err("Set Assoc Resp IE Failed\n");
+	else
+		brcmf_dbg(TRACE, "Applied Vndr IEs for Assoc Resp\n");
+
 	return err;
 }
 
@@ -5342,6 +5480,7 @@ struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,
 	struct brcmf_cfg80211_vif *vif_walk;
 	struct brcmf_cfg80211_vif *vif;
 	bool mbss;
+	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
 
 	brcmf_dbg(TRACE, "allocating virtual interface (size=%zu)\n",
 		  sizeof(*vif));
@@ -5354,7 +5493,8 @@ struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,
 
 	brcmf_init_prof(&vif->profile);
 
-	if (type == NL80211_IFTYPE_AP) {
+	if (type == NL80211_IFTYPE_AP &&
+	    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) {
 		mbss = false;
 		list_for_each_entry(vif_walk, &cfg->vif_list, list) {
 			if (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {
@@ -5393,25 +5533,28 @@ static bool brcmf_is_linkup(struct brcmf_cfg80211_vif *vif,
 	u32 event = e->event_code;
 	u32 status = e->status;
 
-	if (vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_PSK &&
-	    event == BRCMF_E_PSK_SUP &&
-	    status == BRCMF_E_STATUS_FWSUP_COMPLETED)
+	if (event == BRCMF_E_PSK_SUP &&
+	    status == BRCMF_E_STATUS_FWSUP_COMPLETED) {
 		set_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);
+		if (vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_1X)
+			return true;
+	}
+
 	if (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {
 		brcmf_dbg(CONN, "Processing set ssid\n");
 		memcpy(vif->profile.bssid, e->addr, ETH_ALEN);
-		if (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_PSK)
+		if (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_PSK &&
+		    vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_SAE)
 			return true;
 
 		set_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);
 	}
 
 	if (test_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state) &&
-	    test_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state)) {
-		clear_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);
-		clear_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);
+	    test_and_clear_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS,
+			       &vif->sme_state))
 		return true;
-	}
+
 	return false;
 }
 
@@ -5714,6 +5857,11 @@ brcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,
 	cfg80211_roamed(ndev, &roam_info, GFP_KERNEL);
 	brcmf_dbg(CONN, "Report roaming result\n");
 
+	if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X && profile->is_ft) {
+		cfg80211_port_authorized(ndev, profile->bssid, GFP_KERNEL);
+		brcmf_dbg(CONN, "Report port authorized\n");
+	}
+
 	set_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);
 	brcmf_dbg(TRACE, "Exit\n");
 	return err;
@@ -5752,6 +5900,13 @@ brcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,
 		brcmf_dbg(CONN, "Report connect result - connection %s\n",
 			  completed ? "succeeded" : "failed");
 	}
+
+	if (test_and_clear_bit(BRCMF_VIF_STATUS_EAP_SUCCESS,
+			       &ifp->vif->sme_state) &&
+	    profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X) {
+		cfg80211_port_authorized(ndev, profile->bssid, GFP_KERNEL);
+		brcmf_dbg(CONN, "Report port authorized\n");
+	}
 	brcmf_dbg(TRACE, "Exit\n");
 	return 0;
 }
@@ -6602,6 +6757,9 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] = {
  *	#STA <= 1, #AP <= 1, channels = 1, 2 total
  *	#AP <= 4, matching BI, channels = 1, 4 total
  *
+ * no p2p and rsdb:
+ *	#STA <= 2, #AP <= 2, channels = 2, 4 total
+ *
  * p2p, no mchan, and mbss:
  *
  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total
@@ -6613,6 +6771,10 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] = {
  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total
  *	#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total
  *	#AP <= 4, matching BI, channels = 1, 4 total
+ *
+ * p2p, rsdb, and no mbss:
+ *	#STA <= 2, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 2, AP <= 2,
+ *	 channels = 2, 4 total
  */
 static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
 {
@@ -6620,13 +6782,14 @@ static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
 	struct ieee80211_iface_limit *c0_limits = NULL;
 	struct ieee80211_iface_limit *p2p_limits = NULL;
 	struct ieee80211_iface_limit *mbss_limits = NULL;
-	bool mbss, p2p;
+	bool mbss, p2p, rsdb;
 	int i, c, n_combos;
 
 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
+	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
 
-	n_combos = 1 + !!p2p + !!mbss;
+	n_combos = 1 + !!(p2p && !rsdb) + !!mbss;
 	combo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);
 	if (!combo)
 		goto err;
@@ -6637,16 +6800,36 @@ static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
 
 	c = 0;
 	i = 0;
-	c0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);
+	if (p2p && rsdb)
+		c0_limits = kcalloc(4, sizeof(*c0_limits), GFP_KERNEL);
+	else if (p2p)
+		c0_limits = kcalloc(3, sizeof(*c0_limits), GFP_KERNEL);
+	else
+		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
 	if (!c0_limits)
 		goto err;
-	c0_limits[i].max = 1;
-	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-	if (p2p) {
+	if (p2p && rsdb) {
+		combo[c].num_different_channels = 2;
+		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
+					  BIT(NL80211_IFTYPE_P2P_GO) |
+					  BIT(NL80211_IFTYPE_P2P_DEVICE);
+		c0_limits[i].max = 2;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+		c0_limits[i].max = 1;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
+		c0_limits[i].max = 2;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				       BIT(NL80211_IFTYPE_P2P_GO);
+		c0_limits[i].max = 2;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+		combo[c].max_interfaces = 5;
+	} else if (p2p) {
 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))
 			combo[c].num_different_channels = 2;
 		else
 			combo[c].num_different_channels = 1;
+		c0_limits[i].max = 1;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
 		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
 					  BIT(NL80211_IFTYPE_P2P_GO) |
 					  BIT(NL80211_IFTYPE_P2P_DEVICE);
@@ -6655,16 +6838,26 @@ static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
 		c0_limits[i].max = 1;
 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
 				       BIT(NL80211_IFTYPE_P2P_GO);
+		combo[c].max_interfaces = i;
+	} else if (rsdb) {
+		combo[c].num_different_channels = 2;
+		c0_limits[i].max = 2;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+		c0_limits[i].max = 2;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+		combo[c].max_interfaces = 3;
 	} else {
 		combo[c].num_different_channels = 1;
 		c0_limits[i].max = 1;
+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+		c0_limits[i].max = 1;
 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+		combo[c].max_interfaces = i;
 	}
-	combo[c].max_interfaces = i;
 	combo[c].n_limits = i;
 	combo[c].limits = c0_limits;
 
-	if (p2p) {
+	if (p2p && !rsdb) {
 		c++;
 		i = 0;
 		p2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);
@@ -6833,6 +7026,9 @@ static int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp)
 				      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK);
 		wiphy_ext_feature_set(wiphy,
 				      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X);
+	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SAE))
+		wiphy_ext_feature_set(wiphy,
+					NL80211_EXT_FEATURE_SAE_OFFLOAD);
 	}
 	wiphy->mgmt_stypes = brcmf_txrx_stypes;
 	wiphy->max_remain_on_channel_duration = 5000;
@@ -6916,7 +7112,7 @@ static s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)
 
 	brcmf_dongle_scantime(ifp);
 
-	power_mode = cfg->pwr_save ? PM_FAST : PM_OFF;
+	power_mode = cfg->pwr_save ? ifp->drvr->settings->default_pm : PM_OFF;
 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, power_mode);
 	if (err)
 		goto default_conf_out;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
index 5cedee086f4f..a632bbc6f766 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
@@ -142,7 +142,8 @@ struct brcmf_cfg80211_security {
 enum brcmf_profile_fwsup {
 	BRCMF_PROFILE_FWSUP_NONE,
 	BRCMF_PROFILE_FWSUP_PSK,
-	BRCMF_PROFILE_FWSUP_1X
+	BRCMF_PROFILE_FWSUP_1X,
+	BRCMF_PROFILE_FWSUP_SAE,
 };
 
 /**
@@ -157,6 +158,7 @@ struct brcmf_cfg80211_profile {
 	struct brcmf_cfg80211_security sec;
 	struct brcmf_wsec_key key[BRCMF_MAX_DEFAULT_KEYS];
 	enum brcmf_profile_fwsup use_fwsup;
+	bool is_ft;
 };
 
 /**
@@ -186,19 +188,23 @@ enum brcmf_vif_status {
  * @probe_req_ie: IE info for probe request.
  * @probe_res_ie: IE info for probe response.
  * @beacon_ie: IE info for beacon frame.
+ * @assoc_res_ie: IE info for association response frame.
  * @probe_req_ie_len: IE info length for probe request.
  * @probe_res_ie_len: IE info length for probe response.
  * @beacon_ie_len: IE info length for beacon frame.
+ * @assoc_res_ie_len: IE info length for association response frame.
  */
 struct vif_saved_ie {
 	u8  probe_req_ie[IE_MAX_LEN];
 	u8  probe_res_ie[IE_MAX_LEN];
 	u8  beacon_ie[IE_MAX_LEN];
 	u8  assoc_req_ie[IE_MAX_LEN];
+	u8  assoc_res_ie[IE_MAX_LEN];
 	u32 probe_req_ie_len;
 	u32 probe_res_ie_len;
 	u32 beacon_ie_len;
 	u32 assoc_req_ie_len;
+	u32 assoc_res_ie_len;
 };
 
 /**
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
index ba1d279497ea..1239b50d3b19 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
@@ -224,6 +224,24 @@ struct sbsocramregs {
 #define	ARMCR4_BSZ_MASK		0x3f
 #define	ARMCR4_BSZ_MULT		8192
 
+/* Minimum PMU resource mask for 43012C0 */
+#define CY_43012_PMU_MIN_RES_MASK       0xF8BFE77
+
+/* PMU STATUS mask for 43012C0 */
+#define CY_43012_PMU_STATUS_MASK        0x1AC
+
+/* PMU CONTROL EXT mask for 43012C0 */
+#define CY_43012_PMU_CONTROL_EXT_MASK   0x11
+
+/* PMU Watchdog Counter Tick value for 43012C0 */
+#define CY_43012_PMU_WATCHDOG_TICK_VAL  0x04
+
+/* PMU Watchdog Counter Tick value for 4373 */
+#define CY_4373_PMU_WATCHDOG_TICK_VAL  0x04
+
+/* Minimum PMU resource mask for 4373 */
+#define CY_4373_PMU_MIN_RES_MASK       0xFCAFF7F
+
 struct brcmf_core_priv {
 	struct brcmf_core pub;
 	u32 wrapbase;
@@ -444,11 +462,25 @@ static void brcmf_chip_ai_resetcore(struct brcmf_core_priv *core, u32 prereset,
 {
 	struct brcmf_chip_priv *ci;
 	int count;
+	struct brcmf_core *d11core2 = NULL;
+	struct brcmf_core_priv *d11priv2 = NULL;
 
 	ci = core->chip;
 
+	/* special handle two D11 cores reset */
+	if (core->pub.id == BCMA_CORE_80211) {
+		d11core2 = brcmf_chip_get_d11core(&ci->pub, 1);
+		if (d11core2) {
+			brcmf_dbg(INFO, "found two d11 cores, reset both\n");
+			d11priv2 = container_of(d11core2, struct brcmf_core_priv,
+						 pub);
+		}
+	}
+
 	/* must disable first to work for arbitrary current core state */
 	brcmf_chip_ai_coredisable(core, prereset, reset);
+	if (d11priv2)
+		brcmf_chip_ai_coredisable(d11priv2, prereset, reset);
 
 	count = 0;
 	while (ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) &
@@ -460,9 +492,30 @@ static void brcmf_chip_ai_resetcore(struct brcmf_core_priv *core, u32 prereset,
 		usleep_range(40, 60);
 	}
 
+	if (d11priv2) {
+		count = 0;
+		while (ci->ops->read32(ci->ctx,
+				       d11priv2->wrapbase + BCMA_RESET_CTL) &
+				       BCMA_RESET_CTL_RESET) {
+			ci->ops->write32(ci->ctx,
+					 d11priv2->wrapbase + BCMA_RESET_CTL,
+					 0);
+			count++;
+			if (count > 50)
+				break;
+			usleep_range(40, 60);
+		}
+	}
+
 	ci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,
 			 postreset | BCMA_IOCTL_CLK);
 	ci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);
+
+	if (d11priv2) {
+		ci->ops->write32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL,
+				 postreset | BCMA_IOCTL_CLK);
+		ci->ops->read32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL);
+	}
 }
 
 static char *brcmf_chip_name(uint chipid, char *buf, uint len)
@@ -785,7 +838,7 @@ static int brcmf_chip_dmp_get_regaddr(struct brcmf_chip_priv *ci, u32 *eromaddr,
 				      u32 *regbase, u32 *wrapbase)
 {
 	u8 desc;
-	u32 val;
+	u32 val, szdesc;
 	u8 mpnum = 0;
 	u8 stype, sztype, wraptype;
 
@@ -831,14 +884,15 @@ static int brcmf_chip_dmp_get_regaddr(struct brcmf_chip_priv *ci, u32 *eromaddr,
 
 		/* next size descriptor can be skipped */
 		if (sztype == DMP_SLAVE_SIZE_DESC) {
-			val = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
+			szdesc = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
 			/* skip upper size descriptor if present */
-			if (val & DMP_DESC_ADDRSIZE_GT32)
+			if (szdesc & DMP_DESC_ADDRSIZE_GT32)
 				brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
 		}
 
-		/* only look for 4K register regions */
-		if (sztype != DMP_SLAVE_SIZE_4K)
+		/* look for 4K or 8K register regions */
+		if (sztype != DMP_SLAVE_SIZE_4K &&
+		    sztype != DMP_SLAVE_SIZE_8K)
 			continue;
 
 		stype = (val & DMP_SLAVE_TYPE) >> DMP_SLAVE_TYPE_S;
@@ -895,7 +949,8 @@ int brcmf_chip_dmp_erom_scan(struct brcmf_chip_priv *ci)
 
 		/* need core with ports */
 		if (nmw + nsw == 0 &&
-		    id != BCMA_CORE_PMU)
+		    id != BCMA_CORE_PMU &&
+		    id != BCMA_CORE_GCI)
 			continue;
 
 		/* try to obtain register address info */
@@ -1119,6 +1174,21 @@ void brcmf_chip_detach(struct brcmf_chip *pub)
 	kfree(chip);
 }
 
+struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit)
+{
+	struct brcmf_chip_priv *chip;
+	struct brcmf_core_priv *core;
+
+	chip = container_of(pub, struct brcmf_chip_priv, pub);
+	list_for_each_entry(core, &chip->cores, list) {
+		if (core->pub.id == BCMA_CORE_80211) {
+			if (unit-- == 0)
+				return &core->pub;
+		}
+	}
+	return NULL;
+}
+
 struct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *pub, u16 coreid)
 {
 	struct brcmf_chip_priv *chip;
@@ -1161,6 +1231,14 @@ struct brcmf_core *brcmf_chip_get_pmu(struct brcmf_chip *pub)
 	return cc;
 }
 
+struct brcmf_core *brcmf_chip_get_gci(struct brcmf_chip *pub)
+{
+	struct brcmf_core *gci;
+
+	gci = brcmf_chip_get_core(pub, BCMA_CORE_GCI);
+	return gci;
+}
+
 bool brcmf_chip_iscoreup(struct brcmf_core *pub)
 {
 	struct brcmf_core_priv *core;
@@ -1368,6 +1446,7 @@ bool brcmf_chip_sr_capable(struct brcmf_chip *pub)
 		addr = CORE_CC_REG(base, sr_control0);
 		reg = chip->ops->read32(chip->ctx, addr);
 		return (reg & sr_eng_en) != 0;
+	case BRCM_CC_4359_CHIP_ID:
 	case CY_CC_43012_CHIP_ID:
 		addr = CORE_CC_REG(pmu->base, retention_ctl);
 		reg = chip->ops->read32(chip->ctx, addr);
@@ -1385,3 +1464,148 @@ bool brcmf_chip_sr_capable(struct brcmf_chip *pub)
 			       PMU_RCTL_LOGIC_DISABLE_MASK)) == 0;
 	}
 }
+
+void brcmf_chip_reset_pmu_regs(struct brcmf_chip *pub)
+{
+	struct brcmf_chip_priv *chip;
+	u32 addr;
+	u32 base;
+
+	brcmf_dbg(TRACE, "Enter\n");
+
+	chip = container_of(pub, struct brcmf_chip_priv, pub);
+	base = brcmf_chip_get_pmu(pub)->base;
+
+	switch (pub->chip) {
+	case CY_CC_43012_CHIP_ID:
+		/* SW scratch */
+		addr = CORE_CC_REG(base, swscratch);
+		chip->ops->write32(chip->ctx, addr, 0);
+
+		/* PMU status */
+		addr = CORE_CC_REG(base, pmustatus);
+		chip->ops->write32(chip->ctx, addr,
+			CY_43012_PMU_STATUS_MASK);
+
+		/* PMU control ext */
+		addr = CORE_CC_REG(base, pmucontrol_ext);
+		chip->ops->write32(chip->ctx, addr,
+			CY_43012_PMU_CONTROL_EXT_MASK);
+
+		/* PMU watchdog */
+		addr = CORE_CC_REG(base, pmuwatchdog);
+		chip->ops->write32(chip->ctx, addr,
+			CY_43012_PMU_WATCHDOG_TICK_VAL);
+		break;
+
+	default:
+		brcmf_err("Unsupported chip id\n");
+		break;
+	}
+}
+
+void brcmf_chip_set_default_min_res_mask(struct brcmf_chip *pub)
+{
+	struct brcmf_chip_priv *chip;
+	u32 addr;
+	u32 base;
+
+	brcmf_dbg(TRACE, "Enter\n");
+
+	chip = container_of(pub, struct brcmf_chip_priv, pub);
+	base = brcmf_chip_get_pmu(pub)->base;
+	switch (pub->chip) {
+	case CY_CC_43012_CHIP_ID:
+		addr = CORE_CC_REG(base, min_res_mask);
+		chip->ops->write32(chip->ctx, addr,
+			CY_43012_PMU_MIN_RES_MASK);
+		break;
+
+	default:
+		brcmf_err("Unsupported chip id\n");
+		break;
+	}
+}
+
+void brcmf_chip_ulp_reset_lhl_regs(struct brcmf_chip *pub)
+{
+	struct brcmf_chip_priv *chip;
+	u32 base;
+	u32 addr;
+
+	brcmf_dbg(TRACE, "Enter\n");
+
+	chip = container_of(pub, struct brcmf_chip_priv, pub);
+	base = brcmf_chip_get_gci(pub)->base;
+
+	/* LHL Top Level Power Sequence Control */
+	addr = CORE_GCI_REG(base, lhl_top_pwrseq_ctl_adr);
+	chip->ops->write32(chip->ctx, addr, 0);
+
+	/* GPIO Interrupt Enable0 */
+	addr = CORE_GCI_REG(base, gpio_int_en_port_adr[0]);
+	chip->ops->write32(chip->ctx, addr, 0);
+
+	/* GPIO Interrupt Status0 */
+	addr = CORE_GCI_REG(base, gpio_int_st_port_adr[0]);
+	chip->ops->write32(chip->ctx, addr, ~0);
+
+	/* WL ARM Timer0 Interrupt Mask */
+	addr = CORE_GCI_REG(base, lhl_wl_armtim0_intrp_adr);
+	chip->ops->write32(chip->ctx, addr, 0);
+
+	/* WL ARM Timer0 Interrupt Status */
+	addr = CORE_GCI_REG(base, lhl_wl_armtim0_st_adr);
+	chip->ops->write32(chip->ctx, addr, ~0);
+
+	/* WL ARM Timer */
+	addr = CORE_GCI_REG(base, lhl_wl_armtim0_adr);
+	chip->ops->write32(chip->ctx, addr, 0);
+
+	/* WL MAC Timer0 Interrupt Mask */
+	addr = CORE_GCI_REG(base, lhl_wl_mactim0_intrp_adr);
+	chip->ops->write32(chip->ctx, addr, 0);
+
+	/* WL MAC Timer0 Interrupt Status */
+	addr = CORE_GCI_REG(base, lhl_wl_mactim0_st_adr);
+	chip->ops->write32(chip->ctx, addr, ~0);
+
+	/* WL MAC TimerInt0 */
+	addr = CORE_GCI_REG(base, lhl_wl_mactim_int0_adr);
+	chip->ops->write32(chip->ctx, addr, 0x0);
+}
+
+void brcmf_chip_reset_watchdog(struct brcmf_chip *pub)
+{
+	struct brcmf_chip_priv *chip;
+	u32 base;
+	u32 addr;
+
+	brcmf_dbg(TRACE, "Enter\n");
+
+	chip = container_of(pub, struct brcmf_chip_priv, pub);
+	base = brcmf_chip_get_pmu(pub)->base;
+
+	switch (pub->chip) {
+	case CY_CC_43012_CHIP_ID:
+		/* Watchdog res mask */
+		addr = CORE_CC_REG(base, watchdog_res_mask);
+		chip->ops->write32(chip->ctx, addr,
+			CY_43012_PMU_MIN_RES_MASK);
+		break;
+	case CY_CC_4373_CHIP_ID:
+		addr = CORE_CC_REG(base, min_res_mask);
+		chip->ops->write32(chip->ctx, addr,
+			CY_4373_PMU_MIN_RES_MASK);
+		addr = CORE_CC_REG(base, watchdog_res_mask);
+		chip->ops->write32(chip->ctx, addr,
+			CY_4373_PMU_MIN_RES_MASK);
+		addr = CORE_CC_REG(base, pmuwatchdog);
+		chip->ops->write32(chip->ctx, addr,
+			CY_4373_PMU_WATCHDOG_TICK_VAL);
+		mdelay(100);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
index dd0ec3eba6a9..a7098d930155 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
@@ -21,6 +21,9 @@
 #define CORE_CC_REG(base, field) \
 		(base + offsetof(struct chipcregs, field))
 
+#define CORE_GCI_REG(base, field) \
+		(base + offsetof(struct chipgciregs, field))
+
 /**
  * struct brcmf_chip - chip level information.
  *
@@ -93,5 +96,10 @@ void brcmf_chip_resetcore(struct brcmf_core *core, u32 prereset, u32 reset,
 void brcmf_chip_set_passive(struct brcmf_chip *ci);
 bool brcmf_chip_set_active(struct brcmf_chip *ci, u32 rstvec);
 bool brcmf_chip_sr_capable(struct brcmf_chip *pub);
+void brcmf_chip_reset_watchdog(struct brcmf_chip *pub);
+void brcmf_chip_ulp_reset_lhl_regs(struct brcmf_chip *pub);
+void brcmf_chip_reset_pmu_regs(struct brcmf_chip *pub);
+void brcmf_chip_set_default_min_res_mask(struct brcmf_chip *pub);
+struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit);
 
 #endif /* BRCMF_AXIDMP_H */
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
index df13bb7cb51e..d2fc95283a42 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
@@ -30,6 +30,10 @@
 #include "common.h"
 #include "of.h"
 #include "firmware.h"
+#include "fweh.h"
+#include <brcm_hw_ids.h>
+#include "defs.h"
+
 
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Broadcom 802.11 wireless LAN fullmac driver.");
@@ -45,6 +49,9 @@ const u8 ALLFFMAC[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 #define BRCMF_DEFAULT_TXGLOM_SIZE	32  /* max tx frames in glom chain */
 
+#define CLM_LOAD_RETRIES 1 /* # of retries to load clm_blob file */
+
+
 static int brcmf_sdiod_txglomsz = BRCMF_DEFAULT_TXGLOM_SIZE;
 module_param_named(txglomsz, brcmf_sdiod_txglomsz, int, 0);
 MODULE_PARM_DESC(txglomsz, "Maximum tx packet chain size [SDIO]");
@@ -75,6 +82,11 @@ static int brcmf_roamoff;
 module_param_named(roamoff, brcmf_roamoff, int, S_IRUSR);
 MODULE_PARM_DESC(roamoff, "Do not use internal roaming engine");
 
+static int brcmf_sdio_dpc_prio;
+module_param_named(sdio_dpc_prio, brcmf_sdio_dpc_prio, int, S_IRUSR);
+MODULE_PARM_DESC(sdio_dpc_prio, "The scheduling priority of sdio_dpc thread");
+
+
 static int brcmf_eap_restrict;
 module_param_named(eap_restrict, brcmf_eap_restrict, int, 0400);
 MODULE_PARM_DESC(eap_restrict, "Block non-802.1X frames until auth finished");
@@ -83,6 +95,15 @@ static int brcmf_sdio_wq_highpri;
 module_param_named(sdio_wq_highpri, brcmf_sdio_wq_highpri, int, 0);
 MODULE_PARM_DESC(sdio_wq_highpri, "SDIO workqueue is set to high priority");
 
+static int brcmf_frameburst;
+module_param_named(frameburst, brcmf_frameburst, int, 0);
+MODULE_PARM_DESC(frameburst, "Enable firmware frameburst feature");
+
+static int brcmf_max_pm;
+module_param_named(max_pm, brcmf_max_pm, int, 0);
+MODULE_PARM_DESC(max_pm, "Use max power management mode by default");
+
+
 #ifdef DEBUG
 /* always succeed brcmf_bus_started() */
 static int brcmf_ignore_probe_fail;
@@ -178,6 +199,7 @@ static int brcmf_c_process_clm_blob(struct brcmf_if *ifp)
 	u16 dl_flag = DL_BEGIN;
 	u32 status;
 	s32 err;
+	uint retries = 0;
 
 	brcmf_dbg(TRACE, "Enter\n");
 
@@ -188,11 +210,19 @@ static int brcmf_c_process_clm_blob(struct brcmf_if *ifp)
 		return err;
 	}
 
-	err = request_firmware(&clm, clm_name, dev);
+	do {
+		err = request_firmware(&clm, clm_name, dev);
+	} while (err == -EAGAIN && retries++ < CLM_LOAD_RETRIES);
 	if (err) {
-		brcmf_info("no clm_blob available(err=%d), device may have limited channels available\n",
-			   err);
-		return 0;
+		if (err == -ENOENT) {
+			brcmf_dbg(INFO, "continue with CLM data currently present in firmware\n");
+			return 0;
+		} else if (err == -EAGAIN) {
+			brcmf_dbg(INFO, "reached maximum retries(%d)\n",
+				  CLM_LOAD_RETRIES);
+			brcmf_dbg(INFO, "continue with CLM data in firmware\n");
+			return 0;
+		}
 	}
 
 	chunk_buf = kzalloc(sizeof(*chunk_buf) + MAX_CHUNK_LEN - 1, GFP_KERNEL);
@@ -247,6 +277,9 @@ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp)
 	char *clmver;
 	char *ptr;
 	s32 err;
+	struct eventmsgs_ext *eventmask_msg = NULL;
+	u8 msglen;
+	struct brcmf_bus *bus = ifp->drvr->bus_if;
 
 	/* retrieve mac addresses */
 	err = brcmf_fil_iovar_data_get(ifp, "cur_etheraddr", ifp->mac_addr,
@@ -353,6 +386,42 @@ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp)
 		goto done;
 	}
 
+	/* Enable event_msg_ext specific to 43012 chip */
+	if (bus->chip == CY_CC_43012_CHIP_ID) {
+		/* Program event_msg_ext to support event larger than 128 */
+		msglen = (roundup(BRCMF_E_LAST, NBBY) / NBBY) +
+				  EVENTMSGS_EXT_STRUCT_SIZE;
+		/* Allocate buffer for eventmask_msg */
+		eventmask_msg = kzalloc(msglen, GFP_KERNEL);
+		if (!eventmask_msg) {
+			err = -ENOMEM;
+			goto done;
+		}
+
+		/* Read the current programmed event_msgs_ext */
+		eventmask_msg->ver = EVENTMSGS_VER;
+		eventmask_msg->len = roundup(BRCMF_E_LAST, NBBY) / NBBY;
+		err = brcmf_fil_iovar_data_get(ifp, "event_msgs_ext",
+					       eventmask_msg,
+					       msglen);
+
+		/* Enable ULP event */
+		brcmf_dbg(EVENT, "enable event ULP\n");
+		setbit(eventmask_msg->mask, BRCMF_E_ULP);
+
+		/* Write updated Event mask */
+		eventmask_msg->ver = EVENTMSGS_VER;
+		eventmask_msg->command = EVENTMSGS_SET_MASK;
+		eventmask_msg->len = (roundup(BRCMF_E_LAST, NBBY) / NBBY);
+
+		err = brcmf_fil_iovar_data_set(ifp, "event_msgs_ext",
+					       eventmask_msg, msglen);
+		if (err) {
+			brcmf_err("Set event_msgs_ext error (%d)\n", err);
+			goto done;
+		}
+	}
+
 	/* Setup default scan channel time */
 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,
 				    BRCMF_DEFAULT_SCAN_CHANNEL_TIME);
@@ -455,8 +524,12 @@ struct brcmf_mp_device *brcmf_get_module_param(struct device *dev,
 	settings->feature_disable = brcmf_feature_disable;
 	settings->fcmode = brcmf_fcmode;
 	settings->roamoff = !!brcmf_roamoff;
+	settings->sdio_dpc_prio = brcmf_sdio_dpc_prio;
 	settings->eap_restrict = !!brcmf_eap_restrict;
 	settings->sdio_wq_highpri = !!brcmf_sdio_wq_highpri;
+	settings->frameburst = !!brcmf_frameburst;
+	settings->default_pm = !!brcmf_max_pm ? PM_MAX : PM_FAST;
+
 #ifdef DEBUG
 	settings->ignore_probe_fail = !!brcmf_ignore_probe_fail;
 #endif
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
index f415f208db40..c7a01794f5e2 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
@@ -51,6 +51,7 @@ extern struct brcmf_mp_global_t brcmf_mp_global;
  * @roamoff: Firmware roaming off?
  * @eap_restrict: Not allow data tx/rx until 802.1X auth succeeds
  * @sdio_wq_highpri: Tasks submitted to SDIO workqueue will run immediately.
+ * @frameburst: Firmware frame burst mode.
  * @ignore_probe_fail: Ignore probe failure.
  * @country_codes: If available, pointer to struct for translating country codes
  * @bus: Bus specific platform data. Only SDIO at the mmoment.
@@ -63,6 +64,8 @@ struct brcmf_mp_device {
 	bool		eap_restrict;
 	int		sdio_dpc_prio;
 	bool		sdio_wq_highpri;
+	bool		frameburst;
+	int		default_pm;
 	bool		ignore_probe_fail;
 	struct brcmfmac_pd_cc *country_codes;
 	union {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
index e38f78e4d92c..c2ca3b3d2da7 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
@@ -145,6 +145,7 @@ struct brcmf_pub {
 
 	u8 clmver[BRCMF_DCMD_SMLEN];
 	struct brcmf_pkt_filter_enable_le pkt_filter[MAX_PKT_FILTER_COUNT];
+	u8 sta_mac_idx;
 
 };
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
index 35919d9e8e13..23a290f13a88 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
@@ -40,6 +40,7 @@
 #define BRCMF_MSGBUF_VAL	0x00040000
 #define BRCMF_PCIE_VAL		0x00080000
 #define BRCMF_FWCON_VAL		0x00100000
+#define BRCMF_ULP_VAL		0x00200000
 
 /* set default print format */
 #undef pr_fmt
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
index c7c3563f9a53..3069c6efba15 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
@@ -48,6 +48,7 @@ static const struct brcmf_feat_fwcap brcmf_fwcap_map[] = {
 	{ BRCMF_FEAT_MBSS, "mbss" },
 	{ BRCMF_FEAT_MCHAN, "mchan" },
 	{ BRCMF_FEAT_P2P, "p2p" },
+	{ BRCMF_FEAT_SAE, "sae" },
 };
 
 #ifdef DEBUG
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
index 1ab4f1617112..0c8fa7c65162 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
@@ -48,7 +48,8 @@
 	BRCMF_FEAT_DEF(WOWL_ARP_ND) \
 	BRCMF_FEAT_DEF(MFP) \
 	BRCMF_FEAT_DEF(GSCAN) \
-	BRCMF_FEAT_DEF(FWSUP)
+	BRCMF_FEAT_DEF(FWSUP)\
+	BRCMF_FEAT_DEF(SAE)
 
 /*
  * Quirks:
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
index 816f80ea925b..dd165604cbf7 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
@@ -101,7 +101,9 @@ struct brcmf_cfg80211_info;
 	BRCMF_ENUM_DEF(FIFO_CREDIT_MAP, 74) \
 	BRCMF_ENUM_DEF(ACTION_FRAME_RX, 75) \
 	BRCMF_ENUM_DEF(TDLS_PEER_EVENT, 92) \
-	BRCMF_ENUM_DEF(BCMC_CREDIT_SUPPORT, 127)
+	BRCMF_ENUM_DEF(BCMC_CREDIT_SUPPORT, 127) \
+	BRCMF_ENUM_DEF(ULP, 146)
+
 
 #define BRCMF_ENUM_DEF(id, val) \
 	BRCMF_E_##id = (val),
@@ -113,7 +115,7 @@ enum brcmf_fweh_event_code {
 	 * minimum length check in device firmware so it is
 	 * hard-coded here.
 	 */
-	BRCMF_E_LAST = 139
+	BRCMF_E_LAST = 147
 };
 #undef BRCMF_ENUM_DEF
 
@@ -294,6 +296,28 @@ struct brcmf_if_event {
 	u8 role;
 };
 
+enum event_msgs_ext_command {
+	EVENTMSGS_NONE		=	0,
+	EVENTMSGS_SET_BIT	=	1,
+	EVENTMSGS_RESET_BIT	=	2,
+	EVENTMSGS_SET_MASK	=	3
+};
+
+#define EVENTMSGS_VER 1
+#define EVENTMSGS_EXT_STRUCT_SIZE	offsetof(struct eventmsgs_ext, mask[0])
+
+/* len-	for SET it would be mask size from the application to the firmware */
+/*		for GET it would be actual firmware mask size */
+/* maxgetsize -	is only used for GET. indicate max mask size that the */
+/*				application can read from the firmware */
+struct eventmsgs_ext {
+	u8	ver;
+	u8	command;
+	u8	len;
+	u8	maxgetsize;
+	u8	mask[1];
+};
+
 typedef int (*brcmf_fweh_handler_t)(struct brcmf_if *ifp,
 				    const struct brcmf_event_msg *evtmsg,
 				    void *data);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
index 9616c94afb76..a81ebf374aab 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
@@ -53,6 +53,10 @@
 #define BRCMF_WSEC_MAX_PSK_LEN		32
 #define	BRCMF_WSEC_PASSPHRASE		BIT(0)
 
+#define BRCMF_WSEC_MAX_SAE_PASSWORD_LEN 128
+
+
+
 /* primary (ie tx) key */
 #define BRCMF_PRIMARY_KEY		(1 << 1)
 #define DOT11_BSSTYPE_ANY		2
@@ -519,6 +523,18 @@ struct brcmf_wsec_pmk_le {
 	u8 key[2 * BRCMF_WSEC_MAX_PSK_LEN + 1];
 };
 
+/**
+ * struct brcmf_wsec_sae_pwd_le - firmware SAE password material.
+ *
+ * @key_len: number of octets in key materials.
+ * @key: SAE password material.
+ */
+struct brcmf_wsec_sae_pwd_le {
+	__le16 key_len;
+	u8 key[BRCMF_WSEC_MAX_SAE_PASSWORD_LEN];
+};
+
+
 /* Used to get specific STA parameters */
 struct brcmf_scb_val_le {
 	__le32 val;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
index ea87a2182ead..ca39b211fc2e 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
@@ -416,6 +416,7 @@ struct brcmf_fws_mac_descriptor {
 };
 
 #define BRCMF_FWS_HANGER_MAXITEMS	3072
+#define BRCMF_BORROW_RATIO			3
 
 /**
  * enum brcmf_fws_hanger_item_state - state of hanger item.
@@ -512,7 +513,8 @@ struct brcmf_fws_info {
 	u32 fifo_enqpkt[BRCMF_FWS_FIFO_COUNT];
 	int fifo_credit[BRCMF_FWS_FIFO_COUNT];
 	int init_fifo_credit[BRCMF_FWS_FIFO_COUNT];
-	int credits_borrowed[BRCMF_FWS_FIFO_AC_VO + 1];
+	int credits_borrowed[BRCMF_FWS_FIFO_AC_VO + 1]
+		[BRCMF_FWS_FIFO_AC_VO + 1];
 	int deq_node_pos[BRCMF_FWS_FIFO_COUNT];
 	u32 fifo_credit_map;
 	u32 fifo_delay_map;
@@ -583,15 +585,21 @@ static bool brcmf_fws_ifidx_match(struct sk_buff *skb, void *arg)
 static void brcmf_fws_psq_flush(struct brcmf_fws_info *fws, struct pktq *q,
 				int ifidx)
 {
+	struct brcmf_fws_hanger_item *hi;
 	bool (*matchfn)(struct sk_buff *, void *) = NULL;
 	struct sk_buff *skb;
 	int prec;
+	u32 hslot;
 
 	if (ifidx != -1)
 		matchfn = brcmf_fws_ifidx_match;
 	for (prec = 0; prec < q->num_prec; prec++) {
 		skb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);
 		while (skb) {
+			hslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);
+			hi = &fws->hanger.items[hslot];
+			WARN_ON(skb != hi->pkt);
+			hi->state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;
 			brcmu_pkt_buf_free_skb(skb);
 			skb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);
 		}
@@ -1214,13 +1222,11 @@ static void brcmf_fws_return_credits(struct brcmf_fws_info *fws,
 	if (!credits)
 		return;
 
-	fws->fifo_credit_map |= 1 << fifo;
-
-	if ((fifo == BRCMF_FWS_FIFO_AC_BE) &&
-	    (fws->credits_borrowed[0])) {
+	if (fifo > BRCMF_FWS_FIFO_AC_BK &&
+	    fifo <= BRCMF_FWS_FIFO_AC_VO) {
 		for (lender_ac = BRCMF_FWS_FIFO_AC_VO; lender_ac >= 0;
 		     lender_ac--) {
-			borrowed = &fws->credits_borrowed[lender_ac];
+			borrowed = &fws->credits_borrowed[fifo][lender_ac];
 			if (*borrowed) {
 				fws->fifo_credit_map |= (1 << lender_ac);
 				fifo_credit = &fws->fifo_credit[lender_ac];
@@ -1237,7 +1243,11 @@ static void brcmf_fws_return_credits(struct brcmf_fws_info *fws,
 		}
 	}
 
-	fws->fifo_credit[fifo] += credits;
+	if (credits) {
+		fws->fifo_credit[fifo] += credits;
+		fws->fifo_credit_map |= 1 << fifo;
+	}
+
 	if (fws->fifo_credit[fifo] > fws->init_fifo_credit[fifo])
 		fws->fifo_credit[fifo] = fws->init_fifo_credit[fifo];
 
@@ -2029,27 +2039,31 @@ static void brcmf_fws_rollback_toq(struct brcmf_fws_info *fws,
 	}
 }
 
-static int brcmf_fws_borrow_credit(struct brcmf_fws_info *fws)
+static int brcmf_fws_borrow_credit(struct brcmf_fws_info *fws,
+				   int highest_lender_ac, int borrower_ac,
+				   bool borrow_all)
 {
-	int lender_ac;
+	int lender_ac, borrow_limit = 0;
 
-	if (time_after(fws->borrow_defer_timestamp, jiffies)) {
-		fws->fifo_credit_map &= ~(1 << BRCMF_FWS_FIFO_AC_BE);
-		return -ENAVAIL;
-	}
+	for (lender_ac = 0; lender_ac <= highest_lender_ac; lender_ac++) {
 
-	for (lender_ac = 0; lender_ac <= BRCMF_FWS_FIFO_AC_VO; lender_ac++) {
-		if (fws->fifo_credit[lender_ac] > 0) {
-			fws->credits_borrowed[lender_ac]++;
+		if (!borrow_all)
+			borrow_limit =
+			  fws->fifo_credit[lender_ac] / BRCMF_BORROW_RATIO;
+		else
+			borrow_limit = 0;
+
+		if (fws->fifo_credit[lender_ac] > borrow_limit) {
+			fws->credits_borrowed[borrower_ac][lender_ac]++;
 			fws->fifo_credit[lender_ac]--;
 			if (fws->fifo_credit[lender_ac] == 0)
 				fws->fifo_credit_map &= ~(1 << lender_ac);
-			fws->fifo_credit_map |= (1 << BRCMF_FWS_FIFO_AC_BE);
+			fws->fifo_credit_map |= (1 << borrower_ac);
 			brcmf_dbg(DATA, "borrow credit from: %d\n", lender_ac);
 			return 0;
 		}
 	}
-	fws->fifo_credit_map &= ~(1 << BRCMF_FWS_FIFO_AC_BE);
+	fws->fifo_credit_map &= ~(1 << borrower_ac);
 	return -ENAVAIL;
 }
 
@@ -2149,8 +2163,7 @@ int brcmf_fws_process_skb(struct brcmf_if *ifp, struct sk_buff *skb)
 		brcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_DELAYED, fifo, skb);
 		brcmf_fws_schedule_deq(fws);
 	} else {
-		brcmf_err("drop skb: no hanger slot\n");
-		brcmf_txfinalize(ifp, skb, false);
+		brcmf_err("no hanger slot available\n");
 		rc = -ENOMEM;
 	}
 	brcmf_fws_unlock(fws);
@@ -2239,9 +2252,10 @@ static void brcmf_fws_dequeue_worker(struct work_struct *worker)
 			}
 			continue;
 		}
-		while ((fws->fifo_credit[fifo] > 0) ||
+
+		while ((fws->fifo_credit[fifo]) ||
 		       ((!fws->bcmc_credit_check) &&
-			(fifo == BRCMF_FWS_FIFO_BCMC))) {
+				(fifo == BRCMF_FWS_FIFO_BCMC))) {
 			skb = brcmf_fws_deq(fws, fifo);
 			if (!skb)
 				break;
@@ -2251,10 +2265,14 @@ static void brcmf_fws_dequeue_worker(struct work_struct *worker)
 			if (fws->bus_flow_blocked)
 				break;
 		}
-		if ((fifo == BRCMF_FWS_FIFO_AC_BE) &&
-		    (fws->fifo_credit[fifo] <= 0) &&
-		    (!fws->bus_flow_blocked)) {
-			while (brcmf_fws_borrow_credit(fws) == 0) {
+
+		if (fifo >= BRCMF_FWS_FIFO_AC_BE &&
+		    fifo <= BRCMF_FWS_FIFO_AC_VO &&
+		    fws->fifo_credit[fifo] == 0 &&
+		    !fws->bus_flow_blocked) {
+			while (brcmf_fws_borrow_credit(fws,
+						       fifo - 1, fifo,
+						       false) == 0) {
 				skb = brcmf_fws_deq(fws, fifo);
 				if (!skb) {
 					brcmf_fws_return_credits(fws, fifo, 1);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
index 52016373dce7..c8ad5c297468 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
@@ -28,6 +28,7 @@
 #include "fwil_types.h"
 #include "p2p.h"
 #include "cfg80211.h"
+#include "feature.h"
 
 /* parameters used for p2p escan */
 #define P2PAPI_SCAN_NPROBES 1
@@ -498,9 +499,13 @@ static void brcmf_p2p_generate_bss_mac(struct brcmf_p2p_info *p2p, u8 *dev_addr)
 	 * BSSCFGs need to simultaneously co-exist, then this address must be
 	 * different from the P2P Device Address, but also locally administered.
 	 */
-	memcpy(p2p->int_addr, p2p->dev_addr, ETH_ALEN);
-	p2p->int_addr[0] |= 0x02;
-	p2p->int_addr[4] ^= 0x80;
+	memcpy(p2p->conn_int_addr, p2p->dev_addr, ETH_ALEN);
+	p2p->conn_int_addr[0] |= 0x02;
+	p2p->conn_int_addr[4] ^= 0x80;
+
+	memcpy(p2p->conn2_int_addr, p2p->dev_addr, ETH_ALEN);
+	p2p->conn2_int_addr[0] |= 0x02;
+	p2p->conn2_int_addr[4] ^= 0x90;
 }
 
 /**
@@ -2019,7 +2024,7 @@ int brcmf_p2p_ifchange(struct brcmf_cfg80211_info *cfg,
 
 	if_request.type = cpu_to_le16((u16)if_type);
 	if_request.chspec = cpu_to_le16(chanspec);
-	memcpy(if_request.addr, p2p->int_addr, sizeof(if_request.addr));
+	memcpy(if_request.addr, p2p->conn_int_addr, sizeof(if_request.addr));
 
 	brcmf_cfg80211_arm_vif_event(cfg, vif);
 	err = brcmf_fil_iovar_data_set(vif->ifp, "p2p_ifupd", &if_request,
@@ -2165,6 +2170,27 @@ static struct wireless_dev *brcmf_p2p_create_p2pdev(struct brcmf_p2p_info *p2p,
 	return ERR_PTR(err);
 }
 
+int brcmf_p2p_get_conn_idx(struct brcmf_cfg80211_info *cfg)
+{
+	int i;
+	struct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));
+
+	if (!ifp)
+		return -ENODEV;
+
+	for (i = P2PAPI_BSSCFG_CONNECTION; i < P2PAPI_BSSCFG_MAX; i++) {
+		if (!cfg->p2p.bss_idx[i].vif) {
+			if (i == P2PAPI_BSSCFG_CONNECTION2 &&
+			    !(brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {
+				brcmf_err("Multi p2p not supported");
+				return -EIO;
+			}
+			return i;
+		}
+	}
+	return -EIO;
+}
+
 /**
  * brcmf_p2p_add_vif() - create a new P2P virtual interface.
  *
@@ -2183,7 +2209,9 @@ struct wireless_dev *brcmf_p2p_add_vif(struct wiphy *wiphy, const char *name,
 	struct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));
 	struct brcmf_cfg80211_vif *vif;
 	enum brcmf_fil_p2p_if_types iftype;
-	int err;
+	int err = 0;
+	int connidx;
+	u8 *p2p_intf_addr;
 
 	if (brcmf_cfg80211_vif_event_armed(cfg))
 		return ERR_PTR(-EBUSY);
@@ -2209,9 +2237,21 @@ struct wireless_dev *brcmf_p2p_add_vif(struct wiphy *wiphy, const char *name,
 		return (struct wireless_dev *)vif;
 	brcmf_cfg80211_arm_vif_event(cfg, vif);
 
-	err = brcmf_p2p_request_p2p_if(&cfg->p2p, ifp, cfg->p2p.int_addr,
-				       iftype);
+	connidx = brcmf_p2p_get_conn_idx(cfg);
+
+	if (connidx == P2PAPI_BSSCFG_CONNECTION)
+		p2p_intf_addr = cfg->p2p.conn_int_addr;
+	else if (connidx == P2PAPI_BSSCFG_CONNECTION2)
+		p2p_intf_addr = cfg->p2p.conn2_int_addr;
+	else
+		err = -EINVAL;
+
+	if (!err)
+		err =  brcmf_p2p_request_p2p_if(&cfg->p2p, ifp,
+						p2p_intf_addr, iftype);
+
 	if (err) {
+		brcmf_err("request p2p interface failed\n");
 		brcmf_cfg80211_arm_vif_event(cfg, NULL);
 		goto fail;
 	}
@@ -2243,7 +2283,7 @@ struct wireless_dev *brcmf_p2p_add_vif(struct wiphy *wiphy, const char *name,
 		goto fail;
 	}
 
-	cfg->p2p.bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = vif;
+	cfg->p2p.bss_idx[connidx].vif = vif;
 	/* Disable firmware roaming for P2P interface  */
 	brcmf_fil_iovar_int_set(ifp, "roam_off", 1);
 	if (iftype == BRCMF_FIL_P2P_IF_GO) {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h
index 39f0d0218088..fe83962eead3 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h
@@ -25,13 +25,15 @@ struct brcmf_cfg80211_info;
  *
  * @P2PAPI_BSSCFG_PRIMARY: maps to driver's primary bsscfg.
  * @P2PAPI_BSSCFG_DEVICE: maps to driver's P2P device discovery bsscfg.
- * @P2PAPI_BSSCFG_CONNECTION: maps to driver's P2P connection bsscfg.
+ * @P2PAPI_BSSCFG_CONNECTION: maps to driver's 1st P2P connection bsscfg.
+ * @P2PAPI_BSSCFG_CONNECTION2: maps to driver's 2nd P2P connection bsscfg.
  * @P2PAPI_BSSCFG_MAX: used for range checking.
  */
 enum p2p_bss_type {
 	P2PAPI_BSSCFG_PRIMARY, /* maps to driver's primary bsscfg */
 	P2PAPI_BSSCFG_DEVICE, /* maps to driver's P2P device discovery bsscfg */
-	P2PAPI_BSSCFG_CONNECTION, /* maps to driver's P2P connection bsscfg */
+	P2PAPI_BSSCFG_CONNECTION, /* driver's 1st P2P connection bsscfg */
+	P2PAPI_BSSCFG_CONNECTION2, /* driver's 2nd P2P connection bsscfg */
 	P2PAPI_BSSCFG_MAX
 };
 
@@ -130,7 +132,8 @@ struct brcmf_p2p_info {
 	struct brcmf_cfg80211_info *cfg;
 	unsigned long status;
 	u8 dev_addr[ETH_ALEN];
-	u8 int_addr[ETH_ALEN];
+	u8 conn_int_addr[ETH_ALEN];
+	u8 conn2_int_addr[ETH_ALEN];
 	struct p2p_bss bss_idx[P2PAPI_BSSCFG_MAX];
 	struct timer_list listen_timer;
 	u8 listen_channel;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
index e9fcbee61a7b..e1454e0a4e1b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
@@ -78,7 +78,7 @@ static struct brcmf_firmware_mapping brcmf_pcie_fwnames[] = {
 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4371_CHIP_ID, 0xFFFFFFFF, 4371),
 };
 
-#define BRCMF_PCIE_FW_UP_TIMEOUT		2000 /* msec */
+#define BRCMF_PCIE_FW_UP_TIMEOUT		5000 /* msec */
 
 #define BRCMF_PCIE_REG_MAP_SIZE			(32 * 1024)
 
@@ -1972,6 +1972,7 @@ static const struct dev_pm_ops brcmf_pciedrvr_pm = {
 
 static const struct pci_device_id brcmf_pcie_devid_table[] = {
 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4350_DEVICE_ID),
+	BRCMF_PCIE_DEVICE(BRCM_PCIE_4354_RAW_DEVICE_ID),
 	BRCMF_PCIE_DEVICE_SUB(BRCM_PCIE_4355_DEVICE_ID,BRCM_PCIE_VENDOR_ID_BROADCOM,BRCM_PCIE_4355_DEVICE_ID),
 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4356_DEVICE_ID),
 	BRCMF_PCIE_DEVICE(BRCM_PCIE_43567_DEVICE_ID),
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
index 62f1eedc65c2..112d66a5cb3b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
@@ -53,6 +53,7 @@
 
 #define DEFAULT_F2_WATERMARK    0x8
 #define CY_4373_F2_WATERMARK    0x40
+#define CY_4373_F1_MESBUSYCTRL  (CY_4373_F2_WATERMARK | SBSDIO_MESBUSYCTRL_ENAB)
 #define CY_43012_F2_WATERMARK    0x60
 #define CY_4339_F2_WATERMARK	48
 #define CY_4339_MES_WATERMARK	80
@@ -329,6 +330,11 @@ struct rte_console {
 static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 					 const struct firmware *code,
 					 void *nvram, u32 nvram_len);
+static int brcmf_sdio_f2_ready(struct brcmf_sdio *bus);
+static int brcmf_ulp_event_notify(struct brcmf_if *ifp,
+				  const struct brcmf_event_msg *evtmsg,
+				  void *data);
+
 
 #ifdef DEBUG
 /* Device console log buffer state */
@@ -623,6 +629,7 @@ BRCMF_FW_NVRAM_DEF(43430A1, "brcmfmac43430-sdio.bin", "brcmfmac43430-sdio.txt");
 BRCMF_FW_NVRAM_DEF(43455, "brcmfmac43455-sdio.bin", "brcmfmac43455-sdio.txt");
 BRCMF_FW_NVRAM_DEF(4354, "brcmfmac4354-sdio.bin", "brcmfmac4354-sdio.txt");
 BRCMF_FW_NVRAM_DEF(4356, "brcmfmac4356-sdio.bin", "brcmfmac4356-sdio.txt");
+BRCMF_FW_NVRAM_DEF(4359, "brcmfmac4359-sdio.bin", "brcmfmac4359-sdio.txt");
 BRCMF_FW_NVRAM_DEF(4373, "brcmfmac4373-sdio.bin", "brcmfmac4373-sdio.txt");
 BRCMF_FW_NVRAM_DEF(43012, "brcmfmac43012-sdio.bin", "brcmfmac43012-sdio.txt");
 
@@ -644,6 +651,7 @@ static struct brcmf_firmware_mapping brcmf_sdio_fwnames[] = {
 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFFC0, 43455),
 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),
 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
+	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFFFF, 4359),
 	BRCMF_FW_NVRAM_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),
 	BRCMF_FW_NVRAM_ENTRY(CY_CC_43012_CHIP_ID, 0xFFFFFFFF, 43012)
 };
@@ -1092,7 +1100,7 @@ static void brcmf_sdio_get_console_addr(struct brcmf_sdio *bus)
 }
 #endif /* DEBUG */
 
-static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus)
+static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus, u32 *hmbd)
 {
 	u32 intstatus = 0;
 	u32 hmb_data;
@@ -1170,6 +1178,9 @@ static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus)
 			 HMB_DATA_FCDATA_MASK | HMB_DATA_VERSION_MASK))
 		brcmf_err("Unknown mailbox data content: 0x%02x\n",
 			  hmb_data);
+	/* Populate hmb_data if argument is passed for DS1 check later */
+	if (hmbd)
+		*hmbd = hmb_data;
 
 	return intstatus;
 }
@@ -1735,7 +1746,8 @@ brcmf_sdio_read_control(struct brcmf_sdio *bus, u8 *hdr, uint len, uint doff)
 	u8 *buf = NULL, *rbuf;
 	int sdret;
 
-	brcmf_dbg(TRACE, "Enter\n");
+	brcmf_dbg(ULP, "Enter\n");
+
 
 	if (bus->rxblen)
 		buf = vzalloc(bus->rxblen);
@@ -2565,18 +2577,19 @@ brcmf_sdio_ulp_preinit(struct device *dev)
 	brcmf_dbg(TRACE, "Enter\n");
 
 	/* Query ulp_sdioctrl iovar to get the ULP related SHM offsets */
-	err = brcmf_fil_iovar_data_get(ifp, "ulp_sdioctrl", &sdiodev->shm_ulp,
-				       sizeof(sdiodev->shm_ulp));
+	brcmf_fil_iovar_data_get(ifp, "ulp_sdioctrl",
+				 &sdiodev->fmac_ulp.ulp_shm_offset,
+				 sizeof(sdiodev->fmac_ulp.ulp_shm_offset));
 	if (err)
 		brcmf_err("ulp_sdioctrl iovar returned err = %d\n", err);
 
 	sdiodev->ulp = false;
 
-	brcmf_dbg(TRACE, "m_ulp_ctrl_sdio[%x] m_ulp_wakeevt_ind [%x]\n",
-		  M_DS1_CTRL_SDIO(sdiodev->shm_ulp),
-		  M_WAKEEVENT_IND(sdiodev->shm_ulp));
-	brcmf_dbg(TRACE, "m_ulp_wakeind [%x]\n",
-		  M_ULP_WAKE_IND(sdiodev->shm_ulp));
+	brcmf_dbg(ULP, "m_ulp_ctrl_sdio[%x] m_ulp_wakeevt_ind [%x]\n",
+		  M_DS1_CTRL_SDIO(sdiodev->fmac_ulp),
+		  M_WAKEEVENT_IND(sdiodev->fmac_ulp));
+	brcmf_dbg(ULP, "m_ulp_wakeind [%x]\n",
+		  M_ULP_WAKE_IND(sdiodev->fmac_ulp));
 }
 
 /* Reinitialize ARM because In DS1 mode ARM got off */
@@ -2604,7 +2617,7 @@ brcmf_sdio_ulp_reinit_fw(struct brcmf_sdio *bus)
 
 /* Check if device is in DS1 mode and handshake with ULP UCODE */
 static bool
-brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus)
+brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus, u32 hmb_data)
 {
 	int err = 0;
 	u32 value = 0;
@@ -2612,33 +2625,62 @@ brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus)
 	int reg_addr;
 	unsigned long timeout;
 
+	struct brcmf_ulp *fmac_ulp = &bus->sdiodev->fmac_ulp;
+	int i = 0;
+
+	/* If any host mail box data is present, ignore DS1 exit sequence */
+	if (hmb_data)
+		return false;
+	/* Skip if DS1 Exit is already in progress
+	 * This can happen if firmware download is taking more time
+	 */
+	if (fmac_ulp->ulp_state == FMAC_ULP_TRIGGERED)
+		return false;
+
 	value = brcmf_sdiod_regrb(bus->sdiodev, SDIO_CCCR_IOEx, &err);
 
 	if (value == SDIO_FUNC_ENABLE_1) {
-		brcmf_dbg(SDIO, "GOT THE INTERRUPT FROM UCODE\n");
+		brcmf_dbg(ULP, "GOT THE INTERRUPT FROM UCODE\n");
 		bus->sdiodev->ulp = true;
-		ulp_wake_ind = D11SHM_RD(bus->sdiodev, M_ULP_WAKE_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		wowl_wake_ind = D11SHM_RD(bus->sdiodev, M_WAKEEVENT_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-
-		brcmf_dbg(SDIO, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
-			  wowl_wake_ind, ulp_wake_ind);
-
+		fmac_ulp->ulp_state = FMAC_ULP_TRIGGERED;
+		ulp_wake_ind = D11SHM_RDW(bus->sdiodev, M_ULP_WAKE_IND(
+				  bus->sdiodev->fmac_ulp), &err);
+		wowl_wake_ind = D11SHM_RDW(bus->sdiodev, M_WAKEEVENT_IND(
+				  bus->sdiodev->fmac_ulp), &err);
+
+		brcmf_dbg(ULP, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x state %s\n",
+			  wowl_wake_ind, ulp_wake_ind, (fmac_ulp->ulp_state) ?
+			  "DS1 Exit Triggered" : "IDLE State");
 		if (wowl_wake_ind || ulp_wake_ind) {
-			/* TX wake Don't do anything.
+			/* RX wake Don't do anything.
 			 * Just bail out and re-download firmware.
 			 */
+			 /* Print out PHY TX error block when bit 9 set */
+			if ((ulp_wake_ind & C_DS1_PHY_TXERR) &&
+			    M_DS1_PHYTX_ERR_BLK(bus->sdiodev->fmac_ulp)) {
+				brcmf_err("Dump PHY TX Error SHM Locations\n");
+				for (i = 0; i < PHYTX_ERR_BLK_SIZE; i++) {
+					pr_err("0x%x", D11SHM_RDW(bus->sdiodev,
+								  (M_DS1_PHYTX_ERR_BLK
+								  (bus->sdiodev->fmac_ulp) +
+								  (i * 2)), &err));
+				}
+				brcmf_err("\n");
+			}
 		} else {
 			/* RX wake negotiate with MAC */
-			brcmf_dbg(SDIO, "M_DS1_CTRL_SDIO: 0x%08x\n",
-				  (u32)D11SHM_RD(bus->sdiodev,
-				  M_DS1_CTRL_SDIO(bus->sdiodev->shm_ulp),
+			/* TX wake negotiate with MAC */
+			brcmf_dbg(ULP, "M_DS1_CTRL_SDIO: 0x%08x\n",
+				  (u32)D11SHM_RDW(bus->sdiodev,
+				  M_DS1_CTRL_SDIO(bus->sdiodev->fmac_ulp),
 				  &err));
+			val32 = D11SHM_RD(bus->sdiodev, M_DS1_CTRL_SDIO(
+				  bus->sdiodev->fmac_ulp), &err);
+
 			D11SHM_WR(bus->sdiodev, M_DS1_CTRL_SDIO(
-				  bus->sdiodev->shm_ulp),
-				  C_DS1_CTRL_SDIO_DS1_EXIT |
-				  C_DS1_CTRL_REQ_VALID,
+				  bus->sdiodev->fmac_ulp), val32,
+				  (C_DS1_CTRL_SDIO_DS1_EXIT |
+				  C_DS1_CTRL_REQ_VALID),
 				  &err);
 			val32 = D11REG_RD(bus->sdiodev,
 					  D11_MACCONTROL_REG, &err);
@@ -2647,37 +2689,38 @@ brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus)
 				  D11_MACCONTROL_REG, val32, &err);
 
 			/* Poll for PROC_DONE to be set by ucode */
-			value = D11SHM_RD(bus->sdiodev,
-					  M_DS1_CTRL_SDIO(
-					  bus->sdiodev->shm_ulp), &err);
+			value = D11SHM_RDW(bus->sdiodev,
+					   M_DS1_CTRL_SDIO(
+					   bus->sdiodev->fmac_ulp), &err);
 			/* Wait here (polling) for C_DS1_CTRL_PROC_DONE */
 			timeout = jiffies + ULP_HUDI_PROC_DONE_TIME;
 			while (!(value & C_DS1_CTRL_PROC_DONE)) {
-				value = D11SHM_RD(bus->sdiodev,
-						  M_DS1_CTRL_SDIO(
-						  bus->sdiodev->shm_ulp), &err);
+				value = D11SHM_RDW(bus->sdiodev,
+						   M_DS1_CTRL_SDIO
+						   (bus->sdiodev->fmac_ulp),
+						   &err);
 				if (time_after(jiffies, timeout))
 					break;
 				usleep_range(1000, 2000);
 			}
-			brcmf_dbg(SDIO, "M_DS1_CTRL_SDIO: 0x%08x\n",
-				  (u32)D11SHM_RD(bus->sdiodev,
+			brcmf_dbg(ULP, "M_DS1_CTRL_SDIO: 0x%08x\n",
+				  (u32)D11SHM_RDW(bus->sdiodev,
 				  M_DS1_CTRL_SDIO(
-				  bus->sdiodev->shm_ulp), &err));
-			value = D11SHM_RD(bus->sdiodev,
-					  M_DS1_CTRL_SDIO(
-					  bus->sdiodev->shm_ulp), &err);
+				  bus->sdiodev->fmac_ulp), &err));
+			value = D11SHM_RDW(bus->sdiodev,
+					   M_DS1_CTRL_SDIO(
+					   bus->sdiodev->fmac_ulp), &err);
 			if (!(value & C_DS1_CTRL_PROC_DONE)) {
 				brcmf_err("%s: timeout Failed to enter DS1 Exit state!\n",
 					  __func__);
 				return false;
 			}
 		}
-		ulp_wake_ind = D11SHM_RD(bus->sdiodev, M_ULP_WAKE_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		wowl_wake_ind = D11SHM_RD(bus->sdiodev, M_WAKEEVENT_IND(
-				  bus->sdiodev->shm_ulp), &err) >> 16;
-		brcmf_dbg(SDIO, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
+		ulp_wake_ind = D11SHM_RDW(bus->sdiodev, M_ULP_WAKE_IND(
+				  bus->sdiodev->fmac_ulp), &err);
+		wowl_wake_ind = D11SHM_RDW(bus->sdiodev, M_WAKEEVENT_IND(
+				  bus->sdiodev->fmac_ulp), &err);
+		brcmf_dbg(ULP, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
 			  wowl_wake_ind, ulp_wake_ind);
 		reg_addr = CORE_CC_REG(
 			  brcmf_chip_get_pmu(bus->ci)->base, min_res_mask);
@@ -2762,9 +2805,10 @@ static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 
 	/* Handle host mailbox indication */
 	if (intstatus & I_HMB_HOST_INT) {
+		u32 hmb_data = 0;
 		intstatus &= ~I_HMB_HOST_INT;
-		intstatus |= brcmf_sdio_hostmail(bus);
-		if (brcmf_sdio_ulp_pre_redownload_check(bus))
+		intstatus |= brcmf_sdio_hostmail(bus, &hmb_data);
+		if (brcmf_sdio_ulp_pre_redownload_check(bus, hmb_data))
 			brcmf_sdio_ulp_reinit_fw(bus);
 	}
 
@@ -2810,10 +2854,11 @@ static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 	brcmf_sdio_clrintr(bus);
 
 	if (bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL) &&
-	    data_ok(bus)) {
+	    data_ok(bus) && brcmf_sdio_f2_ready(bus)) {
 		sdio_claim_host(bus->sdiodev->func[1]);
 		if (bus->ctrl_frame_stat) {
-			err = brcmf_sdio_tx_ctrlframe(bus,  bus->ctrl_frame_buf,
+			err = brcmf_sdio_tx_ctrlframe(bus,
+						      bus->ctrl_frame_buf,
 						      bus->ctrl_frame_len);
 			bus->ctrl_frame_err = err;
 			wmb();
@@ -3532,6 +3577,7 @@ static void brcmf_sdio_sr_init(struct brcmf_sdio *bus)
 	}
 
 	if (bus->ci->chip == CY_CC_43012_CHIP_ID ||
+	    bus->ci->chip == CY_CC_4373_CHIP_ID ||
 	    bus->ci->chip == BRCM_CC_4339_CHIP_ID ||
 	    bus->ci->chip == BRCM_CC_4354_CHIP_ID ||
 	    bus->ci->chip == BRCM_CC_4345_CHIP_ID) {
@@ -4219,7 +4265,7 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 	u8 saveclk;
 	u8 devctl;
 
-	brcmf_dbg(TRACE, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
+	brcmf_dbg(ULP, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
 	bus_if = dev_get_drvdata(dev);
 	sdiodev = bus_if->bus_priv.sdio;
 	if (err)
@@ -4286,7 +4332,7 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 			brcmf_sdiod_regwb(sdiodev, SBSDIO_WATERMARK, CY_4373_F2_WATERMARK, &err);
 			devctl = brcmf_sdiod_regrb(sdiodev, SBSDIO_DEVICE_CTL, &err);
 			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
-			brcmf_sdiod_regwb(sdiodev, SBSDIO_DEVICE_CTL, devctl, &err);
+			brcmf_sdiod_regwb(sdiodev, SBSDIO_FUNC1_MESBUSYCTRL, CY_4373_F1_MESBUSYCTRL, &err);
 			break;
 		case SDIO_DEVICE_ID_CYPRESS_43012:
 			brcmf_dbg(INFO, "set F2 watermark to 0x%x*4 bytes for 43012\n",
@@ -4299,6 +4345,10 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
 			brcmf_sdiod_regwb(sdiodev,
 					  SBSDIO_DEVICE_CTL, devctl, &err);
+			/* Register for ULP events */
+			brcmf_fweh_register(bus_if->drvr, BRCMF_E_ULP,
+					    brcmf_ulp_event_notify);
+
 			break;
 		case SDIO_DEVICE_ID_BROADCOM_4339:
 			brcmf_sdiod_regwb(sdiodev,
@@ -4355,6 +4405,12 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 			brcmf_err("dongle is not responding\n");
 			goto fail;
 		}
+	} else {
+		/* For ULP, after firmware redownload complete
+		 * set ULP state to IDLE
+		 */
+		if (bus->sdiodev->fmac_ulp.ulp_state == FMAC_ULP_TRIGGERED)
+			bus->sdiodev->fmac_ulp.ulp_state = FMAC_ULP_IDLE;
 	}
 
 	return;
@@ -4544,7 +4600,19 @@ void brcmf_sdio_remove(struct brcmf_sdio *bus)
 				 * necessary cores.
 				 */
 				msleep(20);
-				brcmf_chip_set_passive(bus->ci);
+				if (bus->sdiodev->fmac_ulp.ulp_state ==
+					FMAC_ULP_ENTRY_RECV) {
+					brcmf_chip_ulp_reset_lhl_regs(bus->ci);
+					brcmf_chip_reset_pmu_regs(bus->ci);
+					brcmf_chip_set_default_min_res_mask(
+						bus->ci);
+				} else {
+					brcmf_chip_set_passive(bus->ci);
+				}
+				/* Reset the PMU, backplane and all the
+				 * cores by using the PMUWatchdogCounter.
+				 */
+				brcmf_chip_reset_watchdog(bus->ci);
 				brcmf_sdio_clkctl(bus, CLK_NONE, false);
 				sdio_release_host(bus->sdiodev->func[1]);
 			}
@@ -4600,3 +4668,41 @@ int brcmf_sdio_sleep(struct brcmf_sdio *bus, bool sleep)
 	return ret;
 }
 
+/* Check F2 Ready bit before sending data to Firmware */
+static int
+brcmf_sdio_f2_ready(struct brcmf_sdio *bus)
+{
+	int ret = -1;
+	int iordy_status = 0;
+
+	sdio_claim_host(bus->sdiodev->func[1]);
+	/* Read the status of IOR2 */
+	iordy_status = brcmf_sdiod_regrb(bus->sdiodev,
+					 SDIO_CCCR_IORx,
+					 NULL);
+
+	sdio_release_host(bus->sdiodev->func[1]);
+	ret = iordy_status & SDIO_FUNC_ENABLE_2;
+	return ret;
+}
+
+static int brcmf_ulp_event_notify(struct brcmf_if *ifp,
+				  const struct brcmf_event_msg *evtmsg,
+				  void *data)
+{
+	int err = 0;
+	struct brcmf_bus *bus_if = ifp->drvr->bus_if;
+	struct brcmf_sdio_dev *sdiodev;
+	struct brcmf_sdio *bus;
+	struct brcmf_ulp_event *ulp_event = (struct brcmf_ulp_event *)data;
+
+	sdiodev = bus_if->bus_priv.sdio;
+	bus = sdiodev->bus;
+
+	brcmf_dbg(ULP, "Chip went to DS1 state : action %d\n",
+		  ulp_event->ulp_dongle_action);
+	if (ulp_event->ulp_dongle_action == FMAC_ULP_ENTRY)
+		bus->sdiodev->fmac_ulp.ulp_state = FMAC_ULP_ENTRY_RECV;
+
+	return err;
+}
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
index 7989980dc27f..17b7ab4ede79 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
@@ -107,6 +107,7 @@
 #define SBSDIO_FUNC1_RFRAMEBCHI		0x1001C
 /* MesBusyCtl (rev 11) */
 #define SBSDIO_FUNC1_MESBUSYCTRL	0x1001D
+
 /* Enable busy capability for MES access */
 #define SBSDIO_MESBUSYCTRL_ENAB         0x80
 /* Sdio Core Rev 12 */
@@ -184,12 +185,31 @@ struct ulp_shm_info {
 	u32 m_ulp_ctrl_sdio;
 	u32 m_ulp_wakeevt_ind;
 	u32 m_ulp_wakeind;
+	u32 m_ulp_phytxblk;
 };
 
-struct fmac_ulp {
+/* FMAC ULP state machine */
+#define FMAC_ULP_IDLE		(0)
+#define FMAC_ULP_ENTRY_RECV		(1)
+#define FMAC_ULP_TRIGGERED		(2)
+
+/* BRCMF_E_ULP event data */
+#define FMAC_ULP_EVENT_VERSION		1
+#define FMAC_ULP_DISABLE_CONSOLE		1 /* Disable console */
+#define FMAC_ULP_UCODE_DOWNLOAD		2 /* Download ULP ucode file */
+#define FMAC_ULP_ENTRY		3 /* Inform ulp entry to Host */
+
+struct brcmf_ulp {
+	uint ulp_state;
 	struct ulp_shm_info ulp_shm_offset;
 };
 
+struct brcmf_ulp_event {
+	u16 version;
+	u16 ulp_dongle_action;
+};
+
+
 struct brcmf_sdio_dev {
 	struct sdio_func *func[SDIO_MAX_FUNCS];
 	u8 num_funcs;			/* Supported funcs on client */
@@ -214,7 +234,7 @@ struct brcmf_sdio_dev {
 	bool wowl_enabled;
 	enum brcmf_sdiod_state state;
 	struct brcmf_sdiod_freezer *freezer;
-	struct fmac_ulp shm_ulp;
+	struct brcmf_ulp fmac_ulp;
 	bool ulp;
 };
 
@@ -395,6 +415,7 @@ void brcmf_sdio_trigger_dpc(struct brcmf_sdio *bus);
 #define M_DS1_CTRL_SDIO(ptr)	((ptr).ulp_shm_offset.m_ulp_ctrl_sdio)
 #define M_WAKEEVENT_IND(ptr)	((ptr).ulp_shm_offset.m_ulp_wakeevt_ind)
 #define M_ULP_WAKE_IND(ptr)		((ptr).ulp_shm_offset.m_ulp_wakeind)
+#define M_DS1_PHYTX_ERR_BLK(ptr)	((ptr).ulp_shm_offset.m_ulp_phytxblk)
 
 #define D11_BASE_ADDR			0x18001000
 #define D11_AXI_BASE_ADDR		0xE8000000
@@ -408,17 +429,7 @@ void brcmf_sdio_trigger_dpc(struct brcmf_sdio *bus);
 #define D11_MACCONTROL_REG			D11REG_ADDR(0x120)
 #define D11_MACCONTROL_REG_WAKE		0x4000000
 
-/* Following are the offsets in M_DRVR_UCODE_IF_PTR block. Start address of
- * M_DRVR_UCODE_IF_PTR block is present in M_DRVR_UCODE_IF_PTR.
- */
-
-/* M_ULP_WAKE_IND bits */
-#define ULP_WAKE_IND_WATCHDOG_EXP		0x1
-#define ULP_WAKE_IND_FCBS_ERROR			0x2
-#define ULP_WAKE_IND_RE_TRANSMIT_ERR	0x4
-#define ULP_WAKE_IND_HOST_WKUP			0x8
-#define ULP_WAKE_IND_INVALID_FCBS_BLK	0x10
-
+/* HUDI Sequence SHM bits */
 #define C_DS1_CTRL_SDIO_DS1_SLEEP		0x1
 #define C_DS1_CTRL_SDIO_MAC_ON			0x2
 #define C_DS1_CTRL_SDIO_RADIO_PHY_ON	0x4
@@ -426,12 +437,54 @@ void brcmf_sdio_trigger_dpc(struct brcmf_sdio *bus);
 #define C_DS1_CTRL_PROC_DONE			0x100
 #define C_DS1_CTRL_REQ_VALID			0x200
 
-#define D11SHM_WR(sdh, offset, val, ret) \
-	brcmf_sdiod_regwl(sdh, D11SHM_ADDR(offset), val, ret)
+/* M_ULP_WAKEIND bits */
+#define	C_WATCHDOG_EXPIRY	BIT(0)
+#define	C_FCBS_ERROR		BIT(1)
+#define	C_RETX_FAILURE		BIT(2)
+#define	C_HOST_WAKEUP		BIT(3)
+#define	C_INVALID_FCBS_BLOCK	BIT(4)
+#define	C_HUDI_DS1_EXIT		BIT(5)
+#define	C_LOB_SLEEP		BIT(6)
+#define	C_DS1_PHY_TXERR		BIT(9)
+#define	C_DS1_WAKE_TIMER	BIT(10)
+
+#define PHYTX_ERR_BLK_SIZE		18
+#define D11SHM_FIRST2BYTE_MASK		0xFFFF0000
+#define D11SHM_SECOND2BYTE_MASK		0x0000FFFF
+#define D11SHM_2BYTE_SHIFT		16
 
 #define D11SHM_RD(sdh, offset, ret) \
 	brcmf_sdiod_regrl(sdh, D11SHM_ADDR(offset), ret)
 
+/* SHM Read is motified based on SHM 4 byte alignment as SHM size is 2 bytes and
+ * 2 byte is currently not working on FMAC
+ * If SHM address is not 4 byte aligned, then right shift by 16
+ * otherwise, mask the first two MSB bytes
+ * Suppose data in address 7260 is 0x440002 and it is 4 byte aligned
+ * Correct SHM value is 0x2 for this SHM offset and next SHM value is 0x44
+ */
+#define D11SHM_RDW(sdh, offset, ret) \
+	((offset % 4) ? \
+		(brcmf_sdiod_regrl(sdh, D11SHM_ADDR(offset), ret) \
+		>> D11SHM_2BYTE_SHIFT) : \
+		(brcmf_sdiod_regrl(sdh, D11SHM_ADDR(offset), ret) \
+		& D11SHM_SECOND2BYTE_MASK))
+
+/* SHM is of size 2 bytes, 4 bytes write will overwrite other SHM's
+ * First read 4 bytes and then clear the required two bytes based on
+ * 4 byte alignment, then update the required value and write the
+ * 4 byte value now
+ */
+#define D11SHM_WR(sdh, offset, val, mask, ret) \
+	do { \
+		if ((offset) % 4) \
+			val = (val & D11SHM_SECOND2BYTE_MASK) | \
+				((mask) << D11SHM_2BYTE_SHIFT); \
+		else \
+			val = (mask) | (val & D11SHM_FIRST2BYTE_MASK); \
+		brcmf_sdiod_regwl(sdh, D11SHM_ADDR(offset), val, ret); \
+	} while (0)
+
 #define D11REG_WR(sdh, addr, val, ret) \
 	brcmf_sdiod_regwl(sdh, addr, val, ret)
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
index b27170c12482..e38c56d4b9d0 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
@@ -339,11 +339,12 @@ static int brcmf_usb_tx_ctlpkt(struct device *dev, u8 *buf, u32 len)
 		return err;
 	}
 	timeout = brcmf_usb_ioctl_resp_wait(devinfo);
-	clear_bit(0, &devinfo->ctl_op);
 	if (!timeout) {
 		brcmf_err("Txctl wait timed out\n");
+		usb_kill_urb(devinfo->ctl_urb);
 		err = -EIO;
 	}
+	clear_bit(0, &devinfo->ctl_op);
 	return err;
 }
 
@@ -369,11 +370,12 @@ static int brcmf_usb_rx_ctlpkt(struct device *dev, u8 *buf, u32 len)
 	}
 	timeout = brcmf_usb_ioctl_resp_wait(devinfo);
 	err = devinfo->ctl_urb_status;
-	clear_bit(0, &devinfo->ctl_op);
 	if (!timeout) {
 		brcmf_err("rxctl wait timed out\n");
+		usb_kill_urb(devinfo->ctl_urb);
 		err = -EIO;
 	}
+	clear_bit(0, &devinfo->ctl_op);
 	if (!err)
 		return devinfo->ctl_urb_actual_length;
 	else
@@ -619,6 +621,7 @@ static int brcmf_usb_tx(struct device *dev, struct sk_buff *skb)
 		goto fail;
 	}
 
+	skb_orphan(skb);
 	req->skb = skb;
 	req->devinfo = devinfo;
 	usb_fill_bulk_urb(req->urb, devinfo->usbdev, devinfo->tx_pipe,
diff --git a/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h b/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
index 31580360081c..1bda1aa7af2b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
+++ b/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
@@ -74,6 +74,7 @@
 /* PCIE Device IDs */
 #define BRCM_PCIE_4350_DEVICE_ID	0x43a3
 #define BRCM_PCIE_4354_DEVICE_ID	0x43df
+#define BRCM_PCIE_4354_RAW_DEVICE_ID	0x4354
 #define BRCM_PCIE_4355_DEVICE_ID        0x4355
 #define BRCM_PCIE_4356_DEVICE_ID	0x43ec
 #define BRCM_PCIE_43567_DEVICE_ID	0x43d3
diff --git a/drivers/net/wireless/broadcom/brcm80211/include/brcmu_wifi.h b/drivers/net/wireless/broadcom/brcm80211/include/brcmu_wifi.h
index 91fca79e6158..ff6d937c5f6b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/include/brcmu_wifi.h
+++ b/drivers/net/wireless/broadcom/brcm80211/include/brcmu_wifi.h
@@ -239,6 +239,7 @@ static inline bool ac_bitmap_tst(u8 bitmap, int prec)
 #define WPA2_AUTH_1X_SHA256	0x1000  /* 1X with SHA256 key derivation */
 #define WPA2_AUTH_FT		0x4000	/* Fast BSS Transition */
 #define WPA2_AUTH_PSK_SHA256	0x8000	/* PSK with SHA256 key derivation */
+#define WPA3_AUTH_SAE_PSK	0x40000	/* SAE with 4-way handshake */
 
 #define DOT11_DEFAULT_RTS_LEN		2347
 #define DOT11_DEFAULT_FRAG_LEN		2346
diff --git a/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h b/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
index 1f23092cdad9..f5265966bf18 100644
--- a/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
+++ b/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
@@ -225,8 +225,197 @@ struct chipcregs {
 	u32 PAD[3];
 	u32 retention_grpidx;       /* 0x680 */
 	u32 retention_grpctl;       /* 0x684 */
-	u32 PAD[94];
-	u16 sromotp[768];
+	u32 mac_res_req_timer;      /* 0x688 */
+	u32 mac_res_req_mask;       /* 0x68c */
+	u32 PAD[18];
+	u32 pmucontrol_ext;         /* 0x6d8 */
+	u32 slowclkperiod;          /* 0x6dc */
+	u32 PAD[8];
+	u32 pmuintmask0;            /* 0x700 */
+	u32 pmuintmask1;            /* 0x704 */
+	u32 PAD[14];
+	u32 pmuintstatus;           /* 0x740 */
+	u32 extwakeupstatus;        /* 0x744 */
+	u32 watchdog_res_mask;      /* 0x748 */
+	u32 swscratch;              /* 0x750 */
+	u32 PAD[3];
+	u32 extwakemask[2];         /* 0x760-0x764 */
+	u32 PAD[2];
+	u32 extwakereqmask[2];      /* 0x770-0x774 */
+	u32 PAD[2];
+	u32 pmuintctrl0;            /* 0x780 */
+	u32 pmuintctrl1;            /* 0x784 */
+	u32 PAD[2];
+	u32 extwakectrl[2];         /* 0x790 */
+};
+
+#define CHIPGCIREGOFFS(field) offsetof(struct chipgciregs, field)
+
+struct chipgciregs {
+	u32 gci_corecaps0;                             /* 0x000 */
+	u32 gci_corecaps1;                             /* 0x004 */
+	u32 gci_corecaps2;                             /* 0x008 */
+	u32 gci_corectrl;                              /* 0x00c */
+	u32 gci_corestat;                              /* 0x010 */
+	u32 gci_intstat;                               /* 0x014 */
+	u32 gci_intmask;                               /* 0x018 */
+	u32 gci_wakemask;                              /* 0x01c */
+	u32 gci_levelintstat;                          /* 0x020 */
+	u32 gci_eventintstat;                          /* 0x024 */
+	u32 gci_wakelevelintstat;                      /* 0x028 */
+	u32 gci_wakeeventintstat;                      /* 0x02c */
+	u32 semaphoreintstatus;                        /* 0x030 */
+	u32 semaphoreintmask;                          /* 0x034 */
+	u32 semaphorerequest;                          /* 0x038 */
+	u32 semaphorereserve;                          /* 0x03c */
+	u32 gci_indirect_addr;                         /* 0x040 */
+	u32 gci_gpioctl;                               /* 0x044 */
+	u32 gci_gpiostatus;                            /* 0x048 */
+	u32 gci_gpiomask;                              /* 0x04c */
+	u32 eventsummary;                              /* 0x050 */
+	u32 gci_miscctl;                               /* 0x054 */
+	u32 gci_gpiointmask;                           /* 0x058 */
+	u32 gci_gpiowakemask;                          /* 0x05c */
+	u32 gci_input[32];                             /* 0x060 */
+	u32 gci_event[32];                             /* 0x0e0 */
+	u32 gci_output[4];                             /* 0x160 */
+	u32 gci_control_0;                             /* 0x170 */
+	u32 gci_control_1;                             /* 0x174 */
+	u32 gci_intpolreg;                             /* 0x178 */
+	u32 gci_levelintmask;                          /* 0x17c */
+	u32 gci_eventintmask;                          /* 0x180 */
+	u32 wakelevelintmask;                          /* 0x184 */
+	u32 wakeeventintmask;                          /* 0x188 */
+	u32 hwmask;                                    /* 0x18c */
+	u32 PAD;
+	u32 gci_inbandeventintmask;                    /* 0x194 */
+	u32 PAD;
+	u32 gci_inbandeventstatus;                     /* 0x19c */
+	u32 gci_seciauxtx;                             /* 0x1a0 */
+	u32 gci_seciauxrx;                             /* 0x1a4 */
+	u32 gci_secitx_datatag;                        /* 0x1a8 */
+	u32 gci_secirx_datatag;                        /* 0x1ac */
+	u32 gci_secitx_datamask;                       /* 0x1b0 */
+	u32 gci_seciusef0tx_reg;                       /* 0x1b4 */
+	u32 gci_secif0tx_offset;                       /* 0x1b8 */
+	u32 gci_secif0rx_offset;                       /* 0x1bc */
+	u32 gci_secif1tx_offset;                       /* 0x1c0 */
+	u32 gci_rxfifo_common_ctrl;                    /* 0x1c4 */
+	u32 gci_rxfifoctrl;                            /* 0x1c8 */
+	u32 gci_hw_sema_status;                        /* 0x1cc */
+	u32 gci_seciuartescval;                        /* 0x1d0 */
+	u32 gic_seciuartautobaudctr;                   /* 0x1d4 */
+	u32 gci_secififolevel;                         /* 0x1d8 */
+	u32 gci_seciuartdata;                          /* 0x1dc */
+	u32 gci_secibauddiv;                           /* 0x1e0 */
+	u32 gci_secifcr;                               /* 0x1e4 */
+	u32 gci_secilcr;                               /* 0x1e8 */
+	u32 gci_secimcr;                               /* 0x1ec */
+	u32 gci_secilsr;                               /* 0x1f0 */
+	u32 gci_secimsr;                               /* 0x1f4 */
+	u32 gci_baudadj;                               /* 0x1f8 */
+	u32 gci_inbandintmask;                         /* 0x1fc */
+	u32 gci_chipctrl;                              /* 0x200 */
+	u32 gci_chipsts;                               /* 0x204 */
+	u32 gci_gpioout;                               /* 0x208 */
+	u32 gci_gpioout_read;                          /* 0x20C */
+	u32 gci_mpwaketx;                              /* 0x210 */
+	u32 gci_mpwakedetect;                          /* 0x214 */
+	u32 gci_seciin_ctrl;                           /* 0x218 */
+	u32 gci_seciout_ctrl;                          /* 0x21C */
+	u32 gci_seciin_auxfifo_en;                     /* 0x220 */
+	u32 gci_seciout_txen_txbr;                     /* 0x224 */
+	u32 gci_seciin_rxbrstatus;                     /* 0x228 */
+	u32 gci_seciin_rxerrstatus;                    /* 0x22C */
+	u32 gci_seciin_fcstatus;                       /* 0x230 */
+	u32 gci_seciout_txstatus;                      /* 0x234 */
+	u32 gci_seciout_txbrstatus;                    /* 0x238 */
+	u32 wlan_mem_info;                             /* 0x23C */
+	u32 wlan_bankxinfo;                            /* 0x240 */
+	u32 bt_smem_select;                            /* 0x244 */
+	u32 bt_smem_stby;                              /* 0x248 */
+	u32 bt_smem_status;                            /* 0x24C */
+	u32 wlan_bankxactivepda;                       /* 0x250 */
+	u32 wlan_bankxsleeppda;                        /* 0x254 */
+	u32 wlan_bankxkill;                            /* 0x258 */
+	u32 PAD[41];
+	u32 gci_chipid;                                /* 0x300 */
+	u32 PAD[3];
+	u32 otpstatus;                                 /* 0x310 */
+	u32 otpcontrol;                                /* 0x314 */
+	u32 otpprog;                                   /* 0x318 */
+	u32 otplayout;                                 /* 0x31c */
+	u32 otplayoutextension;                        /* 0x320 */
+	u32 otpcontrol1;                               /* 0x324 */
+	u32 otpprogdata;                               /* 0x328 */
+	u32 PAD[52];
+	u32 otpECCstatus;                              /* 0x3FC */
+	u32 PAD[512];
+	u32 lhl_core_capab_adr;                        /* 0xC00 */
+	u32 lhl_main_ctl_adr;                          /* 0xC04 */
+	u32 lhl_pmu_ctl_adr;                           /* 0xC08 */
+	u32 lhl_extlpo_ctl_adr;                        /* 0xC0C */
+	u32 lpo_ctl_adr;                               /* 0xC10 */
+	u32 lhl_lpo2_ctl_adr;                          /* 0xC14 */
+	u32 lhl_osc32k_ctl_adr;                        /* 0xC18 */
+	u32 lhl_clk_status_adr;                        /* 0xC1C */
+	u32 lhl_clk_det_ctl_adr;                       /* 0xC20 */
+	u32 lhl_clk_sel_adr;                           /* 0xC24 */
+	u32 hidoff_cnt_adr[2];                         /* 0xC28-0xC2C */
+	u32 lhl_autoclk_ctl_adr;                       /* 0xC30 */
+	u32 PAD;
+	u32 lhl_hibtim_adr;                            /* 0xC38 */
+	u32 lhl_wl_ilp_val_adr;                        /* 0xC3C */
+	u32 lhl_wl_armtim0_intrp_adr;                  /* 0xC40 */
+	u32 lhl_wl_armtim0_st_adr;                     /* 0xC44 */
+	u32 lhl_wl_armtim0_adr;                        /* 0xC48 */
+	u32 PAD[9];
+	u32 lhl_wl_mactim0_intrp_adr;                  /* 0xC70 */
+	u32 lhl_wl_mactim0_st_adr;                     /* 0xC74 */
+	u32 lhl_wl_mactim_int0_adr;                    /* 0xC78 */
+	u32 lhl_wl_mactim_frac0_adr;                   /* 0xC7C */
+	u32 lhl_wl_mactim1_intrp_adr;                  /* 0xC80 */
+	u32 lhl_wl_mactim1_st_adr;                     /* 0xC84 */
+	u32 lhl_wl_mactim_int1_adr;                    /* 0xC88 */
+	u32 lhl_wl_mactim_frac1_adr;                   /* 0xC8C */
+	u32 PAD[8];
+	u32 gpio_int_en_port_adr[4];                   /* 0xCB0-0xCBC */
+	u32 gpio_int_st_port_adr[4];                   /* 0xCC0-0xCCC */
+	u32 gpio_ctrl_iocfg_p_adr[64];                 /* 0xCD0-0xDCC */
+	u32 gpio_gctrl_iocfg_p0_p39_adr;               /* 0xDD0 */
+	u32 gpio_gdsctrl_iocfg_p0_p25_p30_p39_adr;     /* 0xDD4 */
+	u32 gpio_gdsctrl_iocfg_p26_p29_adr;            /* 0xDD8 */
+	u32 PAD[8];
+	u32 lhl_gpio_din0_adr;                         /* 0xDFC */
+	u32 lhl_gpio_din1_adr;                         /* 0xE00 */
+	u32 lhl_wkup_status_adr;                       /* 0xE04 */
+	u32 lhl_ctl_adr;                               /* 0xE08 */
+	u32 lhl_adc_ctl_adr;                           /* 0xE0C */
+	u32 lhl_qdxyz_in_dly_adr;                      /* 0xE10 */
+	u32 lhl_optctl_adr;                            /* 0xE14 */
+	u32 lhl_optct2_adr;                            /* 0xE18 */
+	u32 lhl_scanp_cntr_init_val_adr;               /* 0xE1C */
+	u32 lhl_opt_togg_val_adr[6];                   /* 0xE20-0xE34 */
+	u32 lhl_optx_smp_val_adr;                      /* 0xE38 */
+	u32 lhl_opty_smp_val_adr;                      /* 0xE3C */
+	u32 lhl_optz_smp_val_adr;                      /* 0xE40 */
+	u32 lhl_hidoff_keepstate_adr[3];               /* 0xE44-0xE4C */
+	u32 lhl_bt_slmboot_ctl0_adr[4];                /* 0xE50-0xE5C */
+	u32 lhl_wl_fw_ctl;                             /* 0xE60 */
+	u32 lhl_wl_hw_ctl_adr[2];                      /* 0xE64-0xE68 */
+	u32 lhl_bt_hw_ctl_adr;                         /* 0xE6C */
+	u32 lhl_top_pwrseq_en_adr;                     /* 0xE70 */
+	u32 lhl_top_pwrdn_ctl_adr;                     /* 0xE74 */
+	u32 lhl_top_pwrup_ctl_adr;                     /* 0xE78 */
+	u32 lhl_top_pwrseq_ctl_adr;                    /* 0xE7C */
+	u32 lhl_top_pwrdn2_ctl_adr;                    /* 0xE80 */
+	u32 lhl_top_pwrup2_ctl_adr;                    /* 0xE84 */
+	u32 wpt_regon_intrp_cfg_adr;                   /* 0xE88 */
+	u32 bt_regon_intrp_cfg_adr;                    /* 0xE8C */
+	u32 wl_regon_intrp_cfg_adr;                    /* 0xE90 */
+	u32 regon_intrp_st_adr;                        /* 0xE94 */
+	u32 regon_intrp_en_adr;                        /* 0xE98 */
+
 };
 
 /* chipid */
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index cda10719d1d1..4f3779d3aa09 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -669,6 +669,7 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "lineartechnology,ltc2488" },
 	{ .compatible = "ge,achc" },
 	{ .compatible = "semtech,sx1301" },
+	{ .compatible = "spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/usb/dwc3/dwc3-of-simple.c b/drivers/usb/dwc3/dwc3-of-simple.c
index 216ae3886186..eda996b1144b 100644
--- a/drivers/usb/dwc3/dwc3-of-simple.c
+++ b/drivers/usb/dwc3/dwc3-of-simple.c
@@ -28,6 +28,11 @@
 #include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+/*reset gpio5_io05 */
+#define IMX8HMI_USB_HUB_RESET_GPIO 133
 
 struct dwc3_of_simple {
 	struct device		*dev;
@@ -81,6 +86,34 @@ static int dwc3_of_simple_clk_init(struct dwc3_of_simple *simple, int count)
 	return 0;
 }
 
+static int msm_usb_hub_reset(void)
+{
+	int ret;
+	ret = gpio_request(IMX8HMI_USB_HUB_RESET_GPIO, "usb_hub_reset_gpio");
+	if (ret) {
+		printk(KERN_ERR "%s:%d ei=== gpio request failed with ret=%d",
+			__func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = gpio_direction_output(IMX8HMI_USB_HUB_RESET_GPIO, 0);
+	if (ret) {
+		printk(KERN_ERR "%s:%d ei=== can't set direction of reset gpio"
+			" with ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	usleep_range(10, 1000);
+
+	ret = gpio_direction_output(IMX8HMI_USB_HUB_RESET_GPIO, 1);
+	if (ret) {
+		printk(KERN_ERR "%s:%d ei=== can't set direction of reset gpio"
+			" with ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+	return 0;
+}
+
 static int dwc3_of_simple_probe(struct platform_device *pdev)
 {
 	struct dwc3_of_simple	*simple;
@@ -112,6 +145,14 @@ static int dwc3_of_simple_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = msm_usb_hub_reset();
+	if (ret) {
+		printk(KERN_ERR "%s:%d ei=== usb hub reset failed with ret=%d", __func__, __LINE__, ret);
+	}
+	else{
+		printk(KERN_ERR "%s:%d ei=== usb hub reset passed with ret=%d", __func__, __LINE__, ret);
+	}
+
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 	pm_runtime_get_sync(dev);
diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c
index c931ae689a91..cfd6bda0a430 100644
--- a/drivers/usb/serial/cp210x.c
+++ b/drivers/usb/serial/cp210x.c
@@ -317,6 +317,11 @@ static struct usb_serial_driver * const serial_drivers[] = {
 #define CP210X_SET_BAUDRATE	0x1E
 #define CP210X_VENDOR_SPECIFIC	0xFF
 
+/* support Max baud rate */
+#define CP210X_PARTNUM_CP2102N_QFN28 0x20
+#define CP210X_PARTNUM_CP2102N_QFN24 0x21
+#define CP210X_PARTNUM_CP2102N_QFN20 0x22
+
 /* CP210X_IFC_ENABLE */
 #define UART_ENABLE		0x0001
 #define UART_DISABLE		0x0000
@@ -774,7 +779,7 @@ static int cp210x_get_line_ctl(struct usb_serial_port *port, u16 *ctl)
  * cp210x_quantise_baudrate
  * Quantises the baud rate as per AN205 Table 1
  */
-static unsigned int cp210x_quantise_baudrate(unsigned int baud)
+static unsigned int cp210x_quantise_baudrate(unsigned int baud, bool cp2102n)
 {
 	if (baud <= 300)
 		baud = 300;
@@ -805,10 +810,19 @@ static unsigned int cp210x_quantise_baudrate(unsigned int baud)
 	else if (baud <= 491520)   baud = 460800;
 	else if (baud <= 567138)   baud = 500000;
 	else if (baud <= 670254)   baud = 576000;
-	else if (baud < 1000000)
-		baud = 921600;
-	else if (baud > 2000000)
-		baud = 2000000;
+
+	else if (cp2102n) {
+		if (baud <= 960800) baud = 921600;
+		else if (baud <= 1100000) baud = 1000000;
+		else if (baud <= 1350000) baud = 1200000;
+		else if (baud <= 1750000) baud = 1500000;
+		else if (baud <= 2500000) baud = 2000000;
+		else baud = 3000000;
+	} else {
+	if (baud < 1000000) baud = 921600;
+		else if (baud > 2000000) baud = 2000000;
+	}
+
 	return baud;
 }
 
@@ -1060,16 +1074,20 @@ static void cp210x_get_termios_port(struct usb_serial_port *port,
 static void cp210x_change_speed(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
-	u32 baud;
-
-	baud = tty->termios.c_ospeed;
+	bool is_cp2102n;
+	u32 baud = tty->termios.c_ospeed;
 
+	struct cp210x_serial_private *priv = usb_get_serial_data(port->serial);
 	/* This maps the requested rate to a rate valid on cp2102 or cp2103,
 	 * or to an arbitrary rate in [1M,2M].
 	 *
 	 * NOTE: B0 is not implemented.
 	 */
-	baud = cp210x_quantise_baudrate(baud);
+
+	is_cp2102n = (priv->partnum == CP210X_PARTNUM_CP2102N_QFN28) ||
+					(priv->partnum == CP210X_PARTNUM_CP2102N_QFN24) ||
+					(priv->partnum == CP210X_PARTNUM_CP2102N_QFN20);
+	baud = cp210x_quantise_baudrate(baud, is_cp2102n);
 
 	dev_dbg(&port->dev, "%s - setting baud rate to %u\n", __func__, baud);
 	if (cp210x_write_u32_reg(port, CP210X_SET_BAUDRATE, baud)) {
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 0600dadd6a0c..5b95400dda84 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1127,6 +1127,17 @@ static const struct usb_device_id option_ids[] = {
 	  .driver_info = RSVD(1) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_7253),
 	  .driver_info = RSVD(1) },
+#if 1 //Added by Quectel
+	{ USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */
+	{ USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */
+	{ USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC25/EC20 R2.0 */
+	{ USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */
+	{ USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20 */
+	{ USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */
+	{ USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */
+	{ USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */
+	{ USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */
+#endif
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864E) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864G) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_CC864_DUAL) },
@@ -1974,6 +1985,9 @@ static struct usb_serial_driver option_1port_device = {
 	.suspend           = usb_wwan_suspend,
 	.resume            = usb_wwan_resume,
 #endif
+#if 1 //Added by Quectel
+	.reset_resume      = usb_wwan_resume,
+#endif
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {
@@ -1993,6 +2007,25 @@ static int option_probe(struct usb_serial *serial,
 	/* Never bind to the CD-Rom emulation interface	*/
 	if (iface_desc->bInterfaceClass == 0x08)
 		return -ENODEV;
+#if 1 //Added by Quectel
+	//Quectel UC20's interface 4 can be used as USB Network device
+	if(serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
+		serial->dev->descriptor.idProduct == cpu_to_le16(0x9003) &&
+		serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+	//Quectel EC20's interface 4 can be used as USB Network device
+	if(serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
+		serial->dev->descriptor.idProduct == cpu_to_le16(0x9215) &&
+		serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+	//Quectel EC25&EC21&EC20 R2.0&EG91&EG95&EG06&EP06&EM06&BG96's interface 4 can be used as USB Network device
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C) &&
+		serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+#endif
 
 	/*
 	 * Don't bind reserved interfaces (like network ones) which often have
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index 59bfcb3da116..7663ca116068 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -502,6 +502,21 @@ static struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,
 			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
 			  buf, len, callback, ctx);
 
+#if 1
+//Added by Quectel for Zero Packet
+	if (dir == USB_DIR_OUT) {
+		struct usb_device_descriptor *desc = &serial->dev->descriptor;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9090))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9003))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9215))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x2C7C))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+}
+#endif
+
 	return urb;
 }
 
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 55a604ad459f..83b3446a9e87 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -2112,6 +2112,7 @@ enum ieee80211_key_len {
 #define FILS_ERP_MAX_RRK_LEN		64
 
 #define PMK_MAX_LEN			48
+#define SAE_PASSWORD_MAX_LEN		128
 
 /* Public action codes (IEEE Std 802.11-2016, 9.6.8.1, Table 9-307) */
 enum ieee80211_pub_actioncode {
diff --git a/include/linux/mmc/sdio_ids.h b/include/linux/mmc/sdio_ids.h
index 41cf7eae61de..abf9184f6a7f 100644
--- a/include/linux/mmc/sdio_ids.h
+++ b/include/linux/mmc/sdio_ids.h
@@ -42,6 +42,7 @@
 #define SDIO_DEVICE_ID_BROADCOM_43455		0xa9bf
 #define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
 #define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
+#define SDIO_DEVICE_ID_BROADCOM_4359		0x4355
 #define SDIO_DEVICE_ID_CYPRESS_4373		0x4373
 #define SDIO_DEVICE_ID_CYPRESS_43012		43012
 
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 61eb2ec3d79a..09fcf71f8bdb 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -650,6 +650,9 @@ struct survey_info {
  *	CFG80211_MAX_WEP_KEYS WEP keys
  * @wep_tx_key: key index (0..3) of the default TX static WEP key
  * @psk: PSK (for devices supporting 4-way-handshake offload)
+ * @sae_pwd: password for SAE authentication (for devices supporting SAE
+ *	offload)
+ * @sae_pwd_len: length of SAE password (for devices supporting SAE offload)
  */
 struct cfg80211_crypto_settings {
 	u32 wpa_versions;
@@ -664,6 +667,8 @@ struct cfg80211_crypto_settings {
 	struct key_params *wep_keys;
 	int wep_tx_key;
 	const u8 *psk;
+	const u8 *sae_pwd;
+	u16 sae_pwd_len;
 };
 
 /**
@@ -5470,9 +5475,6 @@ cfg80211_connect_timeout(struct net_device *dev, const u8 *bssid,
  * @req_ie_len: association request IEs length
  * @resp_ie: association response IEs (may be %NULL)
  * @resp_ie_len: assoc response IEs length
- * @authorized: true if the 802.1X authentication was done by the driver or is
- *	not needed (e.g., when Fast Transition protocol was used), false
- *	otherwise. Ignored for networks that don't use 802.1X authentication.
  */
 struct cfg80211_roam_info {
 	struct ieee80211_channel *channel;
@@ -5482,7 +5484,6 @@ struct cfg80211_roam_info {
 	size_t req_ie_len;
 	const u8 *resp_ie;
 	size_t resp_ie_len;
-	bool authorized;
 };
 
 /**
@@ -5506,6 +5507,23 @@ struct cfg80211_roam_info {
 void cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,
 		     gfp_t gfp);
 
+/**
+ * cfg80211_port_authorized - notify cfg80211 of successful security association
+ *
+ * @dev: network device
+ * @bssid: the BSSID of the AP
+ * @gfp: allocation flags
+ *
+ * This function should be called by a driver that supports 4 way handshake
+ * offload after a security association was successfully established (i.e.,
+ * the 4 way handshake was completed successfully). The call to this function
+ * should be preceded with a call to cfg80211_connect_result(),
+ * cfg80211_connect_done(), cfg80211_connect_bss() or cfg80211_roamed() to
+ * indicate the 802.11 association.
+ */
+void cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,
+			      gfp_t gfp);
+
 /**
  * cfg80211_disconnected - notify cfg80211 that connection was dropped
  *
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index f41ea5af22ee..c7d29d1ad10d 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -231,6 +231,15 @@
  * use in a FILS shared key connection with PMKSA caching.
  */
 
+/**
+ * DOC: SAE authentication offload
+ *
+ * By setting @NL80211_EXT_FEATURE_SAE_OFFLOAD flag drivers can indicate they
+ * support offloading SAE authentication for WPA3-Personal networks. In
+ * %NL80211_CMD_CONNECT the password for SAE should be specified using
+ * %NL80211_ATTR_SAE_PASSWORD.
+ */
+
 /**
  * enum nl80211_commands - supported nl80211 commands
  *
@@ -569,13 +578,14 @@
  *	authentication/association or not receiving a response from the AP.
  *	Non-zero %NL80211_ATTR_STATUS_CODE value is indicated in that case as
  *	well to remain backwards compatible.
- * @NL80211_CMD_ROAM: notifcation indicating the card/driver roamed by itself.
- *	When the driver roamed in a network that requires 802.1X authentication,
- *	%NL80211_ATTR_PORT_AUTHORIZED should be set if the 802.1X authentication
- *	was done by the driver or if roaming was done using Fast Transition
- *	protocol (in which case 802.1X authentication is not needed). If
- *	%NL80211_ATTR_PORT_AUTHORIZED is not set, user space is responsible for
- *	the 802.1X authentication.
+ *	When establishing a security association, drivers that support 4 way
+ *	handshake offload should send %NL80211_CMD_PORT_AUTHORIZED event when
+ *	the 4 way handshake is completed successfully.
+ * @NL80211_CMD_ROAM: Notification indicating the card/driver roamed by itself.
+ *	When a security association was established with the new AP (e.g. if
+ *	the FT protocol was used for roaming or the driver completed the 4 way
+ *	handshake), this event should be followed by an
+ *	%NL80211_CMD_PORT_AUTHORIZED event.
  * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
  *	userspace that a connection was dropped by the AP or due to other
  *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
@@ -982,6 +992,12 @@
  * @NL80211_CMD_DEL_PMK: For offloaded 4-Way handshake, delete the previously
  *	configured PMK for the authenticator address identified by
  *	&NL80211_ATTR_MAC.
+ * @NL80211_CMD_PORT_AUTHORIZED: An event that indicates that the 4 way
+ *	handshake was completed successfully by the driver. The BSSID is
+ *	specified with &NL80211_ATTR_MAC. Drivers that support 4 way handshake
+ *	offload should send this event after indicating 802.11 association with
+ *	&NL80211_CMD_CONNECT or &NL80211_CMD_ROAM. If the 4 way handshake failed
+ *	&NL80211_CMD_DISCONNECT should be indicated instead.
  *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
@@ -1185,6 +1201,8 @@ enum nl80211_commands {
 	NL80211_CMD_SET_PMK,
 	NL80211_CMD_DEL_PMK,
 
+	NL80211_CMD_PORT_AUTHORIZED,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -2134,10 +2152,37 @@ enum nl80211_commands {
  *	in %NL80211_CMD_CONNECT to indicate that for 802.1X authentication it
  *	wants to use the supported offload of the 4-way handshake.
  * @NL80211_ATTR_PMKR0_NAME: PMK-R0 Name for offloaded FT.
- * @NL80211_ATTR_PORT_AUTHORIZED: flag attribute used in %NL80211_CMD_ROAMED
- *	notification indicating that that 802.1X authentication was done by
- *	the driver or is not needed (because roaming used the Fast Transition
- *	protocol).
+ * @NL80211_ATTR_PORT_AUTHORIZED: (reserved)
+ *
+ * @NL80211_ATTR_EXTERNAL_AUTH_ACTION: Identify the requested external
+ *	authentication operation (u32 attribute with an
+ *	&enum nl80211_external_auth_action value). This is used with the
+ *	%NL80211_CMD_EXTERNAL_AUTH request event.
+ * @NL80211_ATTR_EXTERNAL_AUTH_SUPPORT: Flag attribute indicating that the user
+ *	space supports external authentication. This attribute shall be used
+ *	only with %NL80211_CMD_CONNECT request. The driver may offload
+ *	authentication processing to user space if this capability is indicated
+ *	in NL80211_CMD_CONNECT requests from the user space.
+ *
+ * @NL80211_ATTR_NSS: Station's New/updated  RX_NSS value notified using this
+ *	u8 attribute. This is used with %NL80211_CMD_STA_OPMODE_CHANGED.
+ *
+ * @NL80211_ATTR_TXQ_STATS: TXQ statistics (nested attribute, see &enum
+ *	nl80211_txq_stats)
+ * @NL80211_ATTR_TXQ_LIMIT: Total packet limit for the TXQ queues for this phy.
+ *	The smaller of this and the memory limit is enforced.
+ * @NL80211_ATTR_TXQ_MEMORY_LIMIT: Total memory memory limit (in bytes) for the
+ *	TXQ queues for this phy. The smaller of this and the packet limit is
+ *	enforced.
+ * @NL80211_ATTR_TXQ_QUANTUM: TXQ scheduler quantum (bytes). Number of bytes
+ *	a flow is assigned on each round of the DRR scheduler.
+ * @NL80211_ATTR_HE_CAPABILITY: HE Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION). Can be set
+ *	only if %NL80211_STA_FLAG_WME is set.
+ *
+ * @NL80211_ATTR_SAE_PASSWORD: attribute for passing SAE password material. It
+ *	is used with %NL80211_CMD_CONNECT to provide password for offloading
+ *	SAE authentication for WPA3-Personal networks.
  *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
@@ -2565,6 +2610,23 @@ enum nl80211_attrs {
 	NL80211_ATTR_PMKR0_NAME,
 	NL80211_ATTR_PORT_AUTHORIZED,
 
+	NL80211_ATTR_EXTERNAL_AUTH_ACTION,
+	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT,
+
+	NL80211_ATTR_NSS,
+	NL80211_ATTR_ACK_SIGNAL,
+
+	NL80211_ATTR_CONTROL_PORT_OVER_NL80211,
+
+	NL80211_ATTR_TXQ_STATS,
+	NL80211_ATTR_TXQ_LIMIT,
+	NL80211_ATTR_TXQ_MEMORY_LIMIT,
+	NL80211_ATTR_TXQ_QUANTUM,
+
+	NL80211_ATTR_HE_CAPABILITY,
+
+	NL80211_ATTR_SAE_PASSWORD,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -3958,6 +4020,7 @@ enum nl80211_mfp {
 enum nl80211_wpa_versions {
 	NL80211_WPA_VERSION_1 = 1 << 0,
 	NL80211_WPA_VERSION_2 = 1 << 1,
+	NL80211_WPA_VERSION_3 = 1 << 2,
 };
 
 /**
@@ -4916,6 +4979,40 @@ enum nl80211_feature_flags {
  *	handshake with 802.1X in station mode (will pass EAP frames to the host
  *	and accept the set_pmk/del_pmk commands), doing it in the host might not
  *	be supported.
+ * @NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME: Driver is capable of overriding
+ *	the max channel attribute in the FILS request params IE with the
+ *	actual dwell time.
+ * @NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP: Driver accepts broadcast probe
+ *	response
+ * @NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE: Driver supports sending
+ *	the first probe request in each channel at rate of at least 5.5Mbps.
+ * @NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: Driver supports
+ *	probe request tx deferral and suppression
+ * @NL80211_EXT_FEATURE_MFP_OPTIONAL: Driver supports the %NL80211_MFP_OPTIONAL
+ *	value in %NL80211_ATTR_USE_MFP.
+ * @NL80211_EXT_FEATURE_LOW_SPAN_SCAN: Driver supports low span scan.
+ * @NL80211_EXT_FEATURE_LOW_POWER_SCAN: Driver supports low power scan.
+ * @NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN: Driver supports high accuracy scan.
+ * @NL80211_EXT_FEATURE_DFS_OFFLOAD: HW/driver will offload DFS actions.
+ *	Device or driver will do all DFS-related actions by itself,
+ *	informing user-space about CAC progress, radar detection event,
+ *	channel change triggered by radar detection event.
+ *	No need to start CAC from user-space, no need to react to
+ *	"radar detected" event.
+ * @NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211: Driver supports sending and
+ *	receiving control port frames over nl80211 instead of the netdevice.
+ * @NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT: This Driver support data ack
+ *	rssi if firmware support, this flag is to intimate about ack rssi
+ *	support to nl80211.
+ * @NL80211_EXT_FEATURE_TXQS: Driver supports FQ-CoDel-enabled intermediate
+ *	TXQs.
+ * @NL80211_EXT_FEATURE_SCAN_RANDOM_SN: Driver/device supports randomizing the
+ *	SN in probe request frames if requested by %NL80211_SCAN_FLAG_RANDOM_SN.
+ * @NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT: Driver/device can omit all data
+ *	except for supported rates from the probe request content if requested
+ *	by the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag.
+ * @NL80211_EXT_FEATURE_SAE_OFFLOAD: Device wants to do SAE authentication in
+ *	station mode (SAE password is passed as part of the connect command).
  *
  * @NUM_NL80211_EXT_FEATURES: number of extended features.
  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
@@ -4938,6 +5035,21 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD,
 	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK,
 	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X,
+	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME,
+	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP,
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE,
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,
+	NL80211_EXT_FEATURE_MFP_OPTIONAL,
+	NL80211_EXT_FEATURE_LOW_SPAN_SCAN,
+	NL80211_EXT_FEATURE_LOW_POWER_SCAN,
+	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN,
+	NL80211_EXT_FEATURE_DFS_OFFLOAD,
+	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211,
+	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT,
+	NL80211_EXT_FEATURE_TXQS,
+	NL80211_EXT_FEATURE_SCAN_RANDOM_SN,
+	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
+	NL80211_EXT_FEATURE_SAE_OFFLOAD,
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 90f90c7d8bf9..eaff636169c2 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -217,6 +217,7 @@ enum cfg80211_event_type {
 	EVENT_DISCONNECTED,
 	EVENT_IBSS_JOINED,
 	EVENT_STOPPED,
+	EVENT_PORT_AUTHORIZED,
 };
 
 struct cfg80211_event {
@@ -236,6 +237,9 @@ struct cfg80211_event {
 			u8 bssid[ETH_ALEN];
 			struct ieee80211_channel *channel;
 		} ij;
+		struct {
+			u8 bssid[ETH_ALEN];
+		} pa;
 	};
 };
 
@@ -386,6 +390,7 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			bool wextev);
 void __cfg80211_roamed(struct wireless_dev *wdev,
 		       struct cfg80211_roam_info *info);
+void __cfg80211_port_authorized(struct wireless_dev *wdev, const u8 *bssid);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 void cfg80211_autodisconnect_wk(struct work_struct *work);
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 3de415bca391..c5fb59fa7f67 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -421,6 +421,8 @@ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[NL80211_ATTR_FILS_CACHE_ID] = { .len = 2 },
 	[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },
 	[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },
+	[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,
+					.len = SAE_PASSWORD_MAX_LEN },
 };
 
 /* policy for the key attributes */
@@ -3863,9 +3865,12 @@ static bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,
 			return false;
 		return true;
 	case NL80211_CMD_CONNECT:
-		/* SAE not supported yet */
-		if (auth_type == NL80211_AUTHTYPE_SAE)
+		if (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&
+		    !wiphy_ext_feature_isset(&rdev->wiphy,
+					     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&
+		    auth_type == NL80211_AUTHTYPE_SAE)
 			return false;
+
 		/* FILS with SK PFS or PK not supported yet */
 		if (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||
 		    auth_type == NL80211_AUTHTYPE_FILS_PK)
@@ -8180,6 +8185,16 @@ static int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,
 		settings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);
 	}
 
+	if (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {
+		if (!wiphy_ext_feature_isset(&rdev->wiphy,
+					     NL80211_EXT_FEATURE_SAE_OFFLOAD))
+			return -EINVAL;
+		settings->sae_pwd =
+			nla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);
+		settings->sae_pwd_len =
+			nla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);
+	}
+
 	return 0;
 }
 
@@ -13811,9 +13826,7 @@ void nl80211_send_roamed(struct cfg80211_registered_device *rdev,
 		     info->req_ie)) ||
 	    (info->resp_ie &&
 	     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,
-		     info->resp_ie)) ||
-	    (info->authorized &&
-	     nla_put_flag(msg, NL80211_ATTR_PORT_AUTHORIZED)))
+		     info->resp_ie)))
 		goto nla_put_failure;
 
 	genlmsg_end(msg, hdr);
@@ -13827,6 +13840,37 @@ void nl80211_send_roamed(struct cfg80211_registered_device *rdev,
 	nlmsg_free(msg);
 }
 
+void nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,
+				  struct net_device *netdev, const u8 *bssid)
+{
+	struct sk_buff *msg;
+	void *hdr;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return;
+
+	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);
+	if (!hdr) {
+		nlmsg_free(msg);
+		return;
+	}
+
+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||
+	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))
+		goto nla_put_failure;
+
+	genlmsg_end(msg, hdr);
+
+	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+				NL80211_MCGRP_MLME, GFP_KERNEL);
+	return;
+
+ nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	nlmsg_free(msg);
+}
+
 void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
 			       struct net_device *netdev, u16 reason,
 			       const u8 *ie, size_t ie_len, bool from_ap)
diff --git a/net/wireless/nl80211.h b/net/wireless/nl80211.h
index fc415c8f7aac..79e47fe60c35 100644
--- a/net/wireless/nl80211.h
+++ b/net/wireless/nl80211.h
@@ -59,6 +59,8 @@ void nl80211_send_connect_result(struct cfg80211_registered_device *rdev,
 void nl80211_send_roamed(struct cfg80211_registered_device *rdev,
 			 struct net_device *netdev,
 			 struct cfg80211_roam_info *info, gfp_t gfp);
+void nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,
+				  struct net_device *netdev, const u8 *bssid);
 void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
 			       struct net_device *netdev, u16 reason,
 			       const u8 *ie, size_t ie_len, bool from_ap);
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index d014aea07160..701cfd7acc1b 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -956,7 +956,6 @@ void cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,
 	ev->rm.resp_ie_len = info->resp_ie_len;
 	memcpy((void *)ev->rm.resp_ie, info->resp_ie, info->resp_ie_len);
 	ev->rm.bss = info->bss;
-	ev->rm.authorized = info->authorized;
 
 	spin_lock_irqsave(&wdev->event_lock, flags);
 	list_add_tail(&ev->list, &wdev->event_list);
@@ -965,6 +964,50 @@ void cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,
 }
 EXPORT_SYMBOL(cfg80211_roamed);
 
+void __cfg80211_port_authorized(struct wireless_dev *wdev, const u8 *bssid)
+{
+	ASSERT_WDEV_LOCK(wdev);
+
+	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
+		return;
+
+	if (WARN_ON(!wdev->current_bss) ||
+	    WARN_ON(!ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
+		return;
+
+	nl80211_send_port_authorized(wiphy_to_rdev(wdev->wiphy), wdev->netdev,
+				     bssid);
+}
+
+void cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,
+			      gfp_t gfp)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+	struct cfg80211_event *ev;
+	unsigned long flags;
+
+	if (WARN_ON(!bssid))
+		return;
+
+	ev = kzalloc(sizeof(*ev), gfp);
+	if (!ev)
+		return;
+
+	ev->type = EVENT_PORT_AUTHORIZED;
+	memcpy(ev->pa.bssid, bssid, ETH_ALEN);
+
+	/*
+	 * Use the wdev event list so that if there are pending
+	 * connected/roamed events, they will be reported first.
+	 */
+	spin_lock_irqsave(&wdev->event_lock, flags);
+	list_add_tail(&ev->list, &wdev->event_list);
+	spin_unlock_irqrestore(&wdev->event_lock, flags);
+	queue_work(cfg80211_wq, &rdev->event_work);
+}
+EXPORT_SYMBOL(cfg80211_port_authorized);
+
 void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap)
 {
diff --git a/net/wireless/util.c b/net/wireless/util.c
index a52a0eb44aa0..978f1efe629d 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -964,6 +964,9 @@ void cfg80211_process_wdev_events(struct wireless_dev *wdev)
 		case EVENT_STOPPED:
 			__cfg80211_leave(wiphy_to_rdev(wdev->wiphy), wdev);
 			break;
+		case EVENT_PORT_AUTHORIZED:
+			__cfg80211_port_authorized(wdev, ev->pa.bssid);
+			break;
 		}
 		wdev_unlock(wdev);
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 79adf360897e..2834b2fd5a72 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -31,6 +31,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ADAV803 if I2C
 	select SND_SOC_ADAU1977_SPI if SPI_MASTER
 	select SND_SOC_ADAU1977_I2C if I2C
+	select SND_SOC_A2B24XX_I2C if I2C
 	select SND_SOC_ADAU1701 if I2C
 	select SND_SOC_ADAU7002
 	select SND_SOC_ADS117X
@@ -358,6 +359,14 @@ config SND_SOC_ADAU1977_I2C
 	select SND_SOC_ADAU1977
 	select REGMAP_I2C
 
+config SND_SOC_A2B24XX
+	tristate
+
+config SND_SOC_A2B24XX_I2C
+	tristate
+	select SND_SOC_A2B24XX
+	select REGMAP_I2C
+
 config SND_SOC_ADAU7002
 	tristate "Analog Devices ADAU7002 Stereo PDM-to-I2S/TDM Converter"
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a3bff1ea12cb..62e27deba5d9 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -21,6 +21,8 @@ snd-soc-adau1781-spi-objs := adau1781-spi.o
 snd-soc-adau1977-objs := adau1977.o
 snd-soc-adau1977-spi-objs := adau1977-spi.o
 snd-soc-adau1977-i2c-objs := adau1977-i2c.o
+snd-soc-a2b24xx-objs := a2b24xx.o
+snd-soc-a2b24xx-i2c-objs := a2b24xx-i2c.o
 snd-soc-adau7002-objs := adau7002.o
 snd-soc-adav80x-objs := adav80x.o
 snd-soc-adav801-objs := adav801.o
@@ -269,6 +271,8 @@ obj-$(CONFIG_SND_SOC_ADAU1781_SPI)	+= snd-soc-adau1781-spi.o
 obj-$(CONFIG_SND_SOC_ADAU1977)		+= snd-soc-adau1977.o
 obj-$(CONFIG_SND_SOC_ADAU1977_SPI)	+= snd-soc-adau1977-spi.o
 obj-$(CONFIG_SND_SOC_ADAU1977_I2C)	+= snd-soc-adau1977-i2c.o
+obj-$(CONFIG_SND_SOC_A2B24XX)          += snd-soc-a2b24xx.o
+obj-$(CONFIG_SND_SOC_A2B24XX_I2C)      += snd-soc-a2b24xx-i2c.o
 obj-$(CONFIG_SND_SOC_ADAU7002)	+= snd-soc-adau7002.o
 obj-$(CONFIG_SND_SOC_ADAV80X)  += snd-soc-adav80x.o
 obj-$(CONFIG_SND_SOC_ADAV801)  += snd-soc-adav801.o
diff --git a/sound/soc/codecs/a2b24xx-i2c.c b/sound/soc/codecs/a2b24xx-i2c.c
new file mode 100755
index 000000000000..ec908458dba8
--- /dev/null
+++ b/sound/soc/codecs/a2b24xx-i2c.c
@@ -0,0 +1,64 @@
+/*
+ * A2B24xx driver
+ *
+ * Copyright 2019 Analog Devices Inc.
+ * ADI Automotive Software Team, Bangalore
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/i2c.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <sound/soc.h>
+#include "a2b24xx.h"
+
+
+static int a2b24xx_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct regmap_config config;
+	config = a2b24xx_regmap_config;
+	config.val_bits = 8;
+	config.reg_bits = 8;
+	return a2b24xx_probe(&client->dev,
+		devm_regmap_init_i2c(client, &config),
+		id->driver_data, NULL);
+}
+
+static int a2b24xx_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id a2b24xx_dt_ids[] = {
+	{ .compatible = "adi,a2b24xx", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, a2b24xx_dt_ids);
+#endif
+
+static const struct i2c_device_id a2b24xx_i2c_ids[] = {
+	{ "a2b24xx", A2B24XX },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, a2b24xx_i2c_ids);
+
+static struct i2c_driver a2b24xx_i2c_driver = {
+	.driver = {
+		.name = "a2b24xx",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(a2b24xx_dt_ids),
+	},
+	.probe = a2b24xx_i2c_probe,
+	.remove = a2b24xx_i2c_remove,
+	.id_table = a2b24xx_i2c_ids,
+};
+module_i2c_driver(a2b24xx_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC A2B24xx driver");
+MODULE_AUTHOR("ADI Automotive Software Team, Bangalore");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/a2b24xx.c b/sound/soc/codecs/a2b24xx.c
new file mode 100755
index 000000000000..5ba19a5de0c3
--- /dev/null
+++ b/sound/soc/codecs/a2b24xx.c
@@ -0,0 +1,370 @@
+/*
+ * A2B24XX driver
+ *
+ * Copyright 2019 Analog Devices Inc.
+ *  Author: ADI Automotive Software Team, Bangalore
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define A2B_SETUP_ALSA
+
+#ifdef A2B_SETUP_ALSA
+#include "adi_a2b_i2c_commandlist.h"
+#endif
+#include "a2b24xx.h"
+
+struct a2b24xx
+{
+	struct regmap *regmap;
+	unsigned int sysclk;
+	enum a2b24xx_sysclk_src sysclk_src;
+	enum a2b24xx_type type;
+
+	struct snd_pcm_hw_constraint_list constraints;
+
+	struct device *dev;
+	void (*switch_mode)(struct device *dev);
+
+	unsigned int max_master_fs;
+	bool master;
+};
+
+static const struct reg_default a2b24xx_reg_defaults[] =
+		{{0x00, 0x50} };
+
+/* An example control -  no specific functionality */
+static const DECLARE_TLV_DB_MINMAX_MUTE(a2b24xx_control, 0, 0);
+
+#define A2B24XX_CONTROL(x) \
+	SOC_SINGLE_TLV("A2B" #x "Template", \
+		2, \
+		0, 255, 1, a2b24xx_control)
+
+/* example control */
+static const struct snd_kcontrol_new a2b24xx_snd_controls[] = {A2B24XX_CONTROL(1), };
+
+static int a2b24xx_reset(struct a2b24xx *a2b24xx)
+{
+	int ret = 0;
+
+	regcache_cache_bypass(a2b24xx->regmap, true);
+    /* A2B reset */
+	return ret;
+}
+#ifdef A2B_SETUP_ALSA
+/****************************************************************************/
+/*!
+ @brief          This function calculates reg value based on width and adds
+ it to the data array
+
+ @param [in]     pDstBuf               Pointer to destination array
+ @param [in]     nAddrwidth            Data unpacking boundary(1 byte / 2 byte /4 byte )
+ @param [in]     nAddr            	  Number of words to be copied
+
+ @return          Return code
+ - 0: Success
+ - 1: Failure
+ */
+/********************************************************************************/
+static void adi_a2b_Concat_Addr_Data(unsigned char pDstBuf[], unsigned int nAddrwidth, unsigned int nAddr)
+{
+	/* Store the read values in the place holder */
+	switch (nAddrwidth)
+	{ /* Byte */
+		case 1u:
+			pDstBuf[0u] = (unsigned char)nAddr;
+			break;
+			/* 16 bit word*/
+		case 2u:
+
+			pDstBuf[0u] = (unsigned char)(nAddr >> 8u);
+			pDstBuf[1u] = (unsigned char)(nAddr & 0xFFu);
+
+			break;
+			/* 24 bit word */
+		case 3u:
+			pDstBuf[0u] = (unsigned char)((nAddr & 0xFF0000u) >> 16u);
+			pDstBuf[1u] = (unsigned char)((nAddr & 0xFF00u) >> 8u);
+			pDstBuf[2u] = (unsigned char)(nAddr & 0xFFu);
+			break;
+
+			/* 32 bit word */
+		case 4u:
+			pDstBuf[0u] = (unsigned char)(nAddr >> 24u);
+			pDstBuf[1u] = (unsigned char)((nAddr & 0xFF0000u) >> 16u);
+			pDstBuf[2u] = (unsigned char)((nAddr & 0xFF00u) >> 8u);
+			pDstBuf[3u] = (unsigned char)(nAddr & 0xFFu);
+			break;
+
+		default:
+			break;
+
+	}
+}
+
+static int adi_a2b_I2CWrite(struct device *dev, unsigned short devAddr, unsigned short count, char *bytes)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	client->addr = devAddr;
+	return (i2c_master_send(client, bytes, count));
+}
+
+/****************************************************************************/
+/*!
+ @brief          This function does A2B network discovery
+ and the peripheral configuration
+ @return          None
+
+ */
+/********************************************************************************/
+static void adi_a2b_NetworkSetup(struct device *dev)
+{
+	ADI_A2B_DISCOVERY_CONFIG* pOPUnit;
+	unsigned int nIndex, nIndex1;
+	unsigned int status;
+	/* Maximum number of writes */
+	static unsigned char aDataBuffer[6000];
+	static unsigned char aDataWriteReadBuf[4u];
+	unsigned int nDelayVal;
+
+	/* Loop over all the configuration */
+	for (nIndex = 0; nIndex < CONFIG_LEN; nIndex++)
+	{
+		pOPUnit = &gaA2BConfig[nIndex];
+		/* Operation code*/
+		switch (pOPUnit->eOpCode)
+		{
+			/* Write */
+			case WRITE:
+				adi_a2b_Concat_Addr_Data(&aDataBuffer[0u], pOPUnit->nAddrWidth, pOPUnit->nAddr);
+				(void)memcpy(&aDataBuffer[pOPUnit->nAddrWidth], pOPUnit->paConfigData, pOPUnit->nDataCount);
+				/* printk("Operation number \n %d", nIndex);*/
+				/* PAL Call, replace with custom implementation  */
+				adi_a2b_I2CWrite(dev, pOPUnit->nDeviceAddr, (pOPUnit->nAddrWidth + pOPUnit->nDataCount), &aDataBuffer[0u]);
+				break;
+
+				/* Read */
+			case READ:
+				(void)memset(&aDataBuffer[0u], 0u, pOPUnit->nDataCount);
+				adi_a2b_Concat_Addr_Data(&aDataWriteReadBuf[0u], pOPUnit->nAddrWidth, pOPUnit->nAddr);
+				/* Couple of milli seconds should be OK */
+				mdelay(2);
+				break;
+
+				/* Delay */
+			case DELAY:
+				nDelayVal = 0u;
+				for (nIndex1 = 0u; nIndex1 < pOPUnit->nDataCount; nIndex1++)
+				{
+					nDelayVal = pOPUnit->paConfigData[nIndex1] | nDelayVal << 8u;
+				}
+				mdelay(nDelayVal);
+				break;
+
+			default:
+				break;
+
+		}
+	}
+
+}
+#endif
+
+/* Template functions */
+static int a2b24xx_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(codec);
+	unsigned int rate = params_rate(params);
+	int ret;
+	ret = 0u;
+
+	/* Add custom functionality */
+
+	return ret;
+}
+
+
+/* set pll rate */
+static int a2b24xx_set_pll(struct snd_soc_dai *dai, int pll_id,
+				     int source, unsigned int freq_in, unsigned int freq_out)
+{
+	int ret =0;
+
+	return ret;
+}
+
+static int a2b24xx_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask, unsigned int rx_mask, int slots, int width)
+{
+	/* Add custom functionality */
+
+	return 0;
+}
+
+static int a2b24xx_mute(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(dai->codec);
+
+	/* Add custom functionality */
+
+	return 0;
+}
+
+static int a2b24xx_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(dai->codec);
+	int ret = 0;
+
+	return ret;
+
+}
+
+static int a2b24xx_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(dai->codec);
+
+	/* Add custom functionality */
+	return 0;
+}
+
+static const struct snd_soc_dai_ops a2b24xx_dai_ops ={
+	.startup = a2b24xx_startup,
+	.hw_params = a2b24xx_hw_params,
+	.mute_stream = a2b24xx_mute,
+	.set_fmt = a2b24xx_set_dai_fmt,
+	.set_tdm_slot = a2b24xx_set_tdm_slot,
+	.set_pll = a2b24xx_set_pll,
+};
+
+static struct snd_soc_dai_driver a2b24xx_dai =
+	{
+		.name = "a2b24xx-hifi",
+		.capture =
+		{
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 32,
+		.rates = SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+		.sig_bits = 24, },
+		.playback =
+			{
+				.stream_name = "Playback",
+				.channels_min = 1,
+				.channels_max = 32,
+				.rates = SNDRV_PCM_RATE_KNOT,
+				.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE, .sig_bits = 24,
+			},
+			.ops = &a2b24xx_dai_ops,
+	};
+
+/* Supported rates */
+static const unsigned int a2b24xx_rates[] =
+ {1500, 2000,2400, 3000, 8000, 12000, 24000, 48000,  };
+
+/* Check system clock */
+static bool a2b24xx_check_sysclk(unsigned int mclk, unsigned int base_freq)
+{
+	unsigned int mcs;
+
+	return true;
+}
+
+/* set system clock */
+static int a2b24xx_set_sysclk(struct snd_soc_codec *codec, int clk_id, int source, unsigned int freq, int dir)
+{
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(codec);
+	unsigned int mask = 0;
+	unsigned int clk_src;
+	unsigned int ret = 0;
+
+	/* No functionality */
+
+	return 0;
+}
+/* Codec probe */
+static int a2b24xx_codec_probe(struct snd_soc_codec *codec)
+{
+	struct a2b24xx *a2b24xx = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+#ifdef A2B_SETUP_ALSA
+	/* Setting up A2B network */
+	adi_a2b_NetworkSetup(codec->dev);
+#endif
+
+	return ret;
+}
+
+static struct snd_soc_codec_driver a2b24xx_codec_driver =
+{
+	.probe = a2b24xx_codec_probe,
+	.set_sysclk = a2b24xx_set_sysclk,
+};
+/* driver probe */
+int a2b24xx_probe(struct device *dev, struct regmap *regmap, enum a2b24xx_type type, void (*switch_mode)(struct device *dev))
+{
+	struct a2b24xx *a2b24xx;
+	int ret;
+
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	a2b24xx = devm_kzalloc(dev, sizeof(*a2b24xx), GFP_KERNEL);
+	if (a2b24xx == NULL)
+		return -ENOMEM;
+
+	a2b24xx->dev = dev;
+	a2b24xx->type = type;
+	a2b24xx->regmap = regmap;
+	a2b24xx->switch_mode = switch_mode;
+	a2b24xx->max_master_fs = 48000;
+
+	a2b24xx->constraints.list = a2b24xx_rates;
+	a2b24xx->constraints.count = ARRAY_SIZE(a2b24xx_rates);
+
+	dev_set_drvdata(dev, a2b24xx);
+
+	return snd_soc_register_codec(dev, &a2b24xx_codec_driver, &a2b24xx_dai, 1);
+
+}
+EXPORT_SYMBOL_GPL(a2b24xx_probe);
+
+static bool a2b24xx_register_volatile(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+const struct regmap_config a2b24xx_regmap_config =
+{
+	.max_register = 255,
+	.volatile_reg = a2b24xx_register_volatile,
+	.cache_type = REGCACHE_NONE,
+	.reg_defaults = a2b24xx_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(a2b24xx_reg_defaults),
+};
+EXPORT_SYMBOL_GPL(a2b24xx_regmap_config);
+
+MODULE_DESCRIPTION("ASoC A2B24XX driver");
+MODULE_AUTHOR("ADI Automotive Software Team, Bangalore");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/a2b24xx.h b/sound/soc/codecs/a2b24xx.h
new file mode 100755
index 000000000000..e29c6954b6ce
--- /dev/null
+++ b/sound/soc/codecs/a2b24xx.h
@@ -0,0 +1,37 @@
+/*
+ * A2B24XX driver
+ *
+ * Copyright 2019 Analog Devices Inc.
+ *  Author: ADI Automotive Software Team, Bangalore
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef __SOUND_SOC_CODECS_A2B24XX_H__
+#define __SOUND_SOC_CODECS_A2B24XX_H__
+
+#include <linux/regmap.h>
+
+
+struct device;
+
+enum a2b24xx_type {
+	A2B24XX,
+
+};
+
+int a2b24xx_probe(struct device *dev, struct regmap *regmap,
+	enum a2b24xx_type type, void (*switch_mode)(struct device *dev));
+
+extern const struct regmap_config a2b24xx_regmap_config;
+
+enum a2b24xx_clk_id {
+	A2B24XX_SYSCLK,
+};
+
+enum a2b24xx_sysclk_src {
+	A2B24XX_SYSCLK_SRC_MCLK,
+	A2B24XX_SYSCLK_SRC_LRCLK,
+};
+
+#endif
diff --git a/sound/soc/codecs/adi_a2b_i2c_commandlist.h b/sound/soc/codecs/adi_a2b_i2c_commandlist.h
new file mode 100755
index 000000000000..77b41edb531b
--- /dev/null
+++ b/sound/soc/codecs/adi_a2b_i2c_commandlist.h
@@ -0,0 +1,1525 @@
+/*******************************************************************************
+* A2B24xx I2C Commandlist
+*
+* Copyright 2019 Analog Devices Inc.
+*
+* ADI Automotive Software Team, Bangalore
+*
+* Licensed under GPL-2
+*****************************************************************************/
+
+/*! \addtogroup ADI_A2B_DISCOVERY_CONFIG ADI_A2B_DISCOVERY_CONFIG
+* @{
+*/
+#ifndef _ADI_A2B_I2C_LIST_H_
+#define _ADI_A2B_I2C_LIST_H_
+
+/*! \struct ADI_A2B_DISCOVERY_CONFIG
+A2B discovery config unit structure
+*/
+typedef struct
+ {
+/*!  Device address */
+	unsigned char nDeviceAddr;
+
+/*!  Operation code */
+	unsigned char eOpCode;
+
+/*! Reg Sub address width (in bytes) */
+	unsigned char nAddrWidth;
+
+/*! Reg Sub address */
+	unsigned int nAddr;
+
+/*! Reg data width (in bytes) */
+	unsigned char nDataWidth;
+
+/*! Reg data count (in bytes) */
+	unsigned short nDataCount;
+
+/*! Config Data */
+	unsigned char* paConfigData;
+
+
+} ADI_A2B_DISCOVERY_CONFIG;
+
+#define WRITE   ((unsigned char) 0x00u)
+#define READ    ((unsigned char) 0x01u)
+#define DELAY   ((unsigned char) 0x02u)
+#define INVALID ((unsigned char) 0xffu)
+
+#define CONFIG_LEN (207)
+
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data0[1] =
+{
+	0x84u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data1[1] =
+{
+	0x19u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTTYPE_Data2[1] =
+{
+	0x19u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTMSK0_Data3[1] =
+{
+	0x77u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTMSK1_Data4[1] =
+{
+	0x7Eu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTMSK2_Data5[1] =
+{
+	0x0Fu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_RESPCYCS_Data6[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data7[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2SGCFG_Data8[1] =
+{
+	0x42u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data9[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_DISCVRY_Data10[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data11[1] =
+{
+	0x32u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data12[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data13[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data14[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_VENDOR_Data0[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_PRODUCT_Data1[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_VERSION_Data2[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data15[1] =
+{
+	0x21u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data16[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_SWCTL_Data3[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_DISCVRY_Data17[1] =
+{
+	0x7Bu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data18[1] =
+{
+	0x32u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data19[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data20[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data21[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_VENDOR_Data0[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_PRODUCT_Data1[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_VERSION_Data2[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data22[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_SWCTL_Data4[1] =
+{
+	0x21u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data23[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_BCDNSLOTS_Data3[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_LDNSLOTS_Data4[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_LUPSLOTS_Data5[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2CCFG_Data6[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_SYNCOFFSET_Data7[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2SGCFG_Data8[1] =
+{
+	0xE0u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2SCFG_Data9[1] =
+{
+	0x91u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2SRATE_Data10[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_PDMCTL_Data11[1] =
+{
+	0x18u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_ERRMGMT_Data12[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIODAT_Data13[1] =
+{
+	0x10u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOOEN_Data14[1] =
+{
+	0x10u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOIEN_Data15[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_PINTEN_Data16[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_PINTINV_Data17[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_PINCFG_Data18[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_TESTMODE_Data19[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_CLK1CFG_Data20[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_CLK2CFG_Data21[1] =
+{
+	0xC1u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_UPMASK0_Data22[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_UPMASK1_Data23[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_UPMASK2_Data24[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_UPMASK3_Data25[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_UPOFFSET_Data26[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_DNMASK0_Data27[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_DNMASK1_Data28[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_DNMASK2_Data29[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_DNMASK3_Data30[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_DNOFFSET_Data31[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD0MSK_Data32[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD1MSK_Data33[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD2MSK_Data34[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD3MSK_Data35[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD4MSK_Data36[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD5MSK_Data37[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD6MSK_Data38[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIOD7MSK_Data39[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIODINV_Data40[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_GPIODEN_Data41[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_MBOX0CTL_Data42[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_MBOX1CTL_Data43[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_SUSCFG_Data44[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2SRRSOFFS_Data45[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_I2SRRCTL_Data46[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_INTMSK0_Data47[1] =
+{
+	0x77u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_INTMSK1_Data48[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_BECCTL_Data49[1] =
+{
+	0xEFu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADRSet_Data24[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BSlaveNode1WBZ_CHIPSet_Data50[1] =
+{
+	0x39u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADREnable_Data25[1] =
+{
+	0x21u
+};
+
+static unsigned char gaConfig_ADAU1761_SampleRate_Data0[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_ADAU1761_DSPRun_Data1[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_ClockControl_Data2[1] =
+{
+	0x0Fu
+};
+
+static unsigned char gaConfig_ADAU1761_PLLControl_Data3[6] =
+{
+	0x00u,	0x01u,	0x00u,	0x00u,	0x20u,	0x03u
+};
+
+static unsigned char gaConfig_ADAU1761_Delay_Data4[2] =
+{
+	0x00u,	0x64u
+};
+
+static unsigned char gaConfig_ADAU1761_SerialPort_Data5[2] =
+{
+	0x10u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_ALCControl_Data6[4] =
+{
+	0x00u,	0x00u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_MicrophoneControl_Data7[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_RecordInput_Data8[8] =
+{
+	0x00u,	0x01u,	0x05u,	0x01u,	0x05u,	0x00u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_ADCControl_Data9[3] =
+{
+	0x13u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_PlaybackOutput_Data10[14] =
+{
+	0x21u,	0x00u,	0x41u,	0x00u,	0x01u,	0x01u,	0x01u,	0xE6u,	0xE7u,	0xE4u,
+	0xE4u,	0xE5u,	0x08u,	0x03u
+};
+
+static unsigned char gaConfig_ADAU1761_ConverterControl_Data11[2] =
+{
+	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_DACControl_Data12[3] =
+{
+	0x03u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_SerialPort_Data13[1] =
+{
+	0xFFu
+};
+
+static unsigned char gaConfig_ADAU1761_CommunicationPort_Data14[2] =
+{
+	0xA0u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_JackDetect_Data15[1] =
+{
+	0x08u
+};
+
+static unsigned char gaConfig_ADAU1761_DSPON_Data16[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_ADAU1761_CRCRegisters_Data17[5] =
+{
+	0x41u,	0x7Fu,	0x06u,	0x7Fu,	0x01u
+};
+
+static unsigned char gaConfig_ADAU1761_GPIORegisters_Data18[4] =
+{
+	0x00u,	0x00u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_NonModulo_Data19[2] =
+{
+	0x10u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_WatchdogRegisters_Data20[5] =
+{
+	0x00u,	0x04u,	0x00u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_SamplingRate_Data21[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_ADAU1761_RoutingMatrix_Data22[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_RoutingMatrix_Data23[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_SerialData_Data24[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_DSPSlew_Data25[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_SerialPort_Data26[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_ClockEnable_Data27[2] =
+{
+	0x7Fu,	0x03u
+};
+
+static unsigned char gaConfig_ADAU1761_ProgramData_Data28[1730] =
+{
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFEu,	0xE0u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0x34u,	0x00u,	0x00u,	0x00u,	0xFFu,	0x2Cu,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0x54u,	0x00u,	0x00u,	0x00u,	0xFFu,	0x5Cu,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0xF5u,	0x08u,	0x20u,	0x00u,	0xFFu,	0x38u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0x80u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFEu,	0xE8u,	0x0Cu,	0x00u,	0x00u,
+	0xFEu,	0x30u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFFu,	0xE8u,	0x07u,	0x20u,	0x08u,
+	0x00u,	0x00u,	0x06u,	0xA0u,	0x00u,	0xFFu,	0xE0u,	0x00u,	0xC0u,	0x00u,
+	0xFFu,	0x80u,	0x07u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0x00u,	0x00u,	0x00u,	0x00u,	0xFEu,	0xC0u,	0x22u,	0x00u,	0x27u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFEu,	0xE8u,	0x1Eu,	0x00u,	0x00u,
+	0xFFu,	0xE8u,	0x01u,	0x20u,	0x00u,	0xFFu,	0xD8u,	0x01u,	0x03u,	0x00u,
+	0x00u,	0x07u,	0xC6u,	0x00u,	0x00u,	0xFFu,	0x08u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0xF4u,	0x00u,	0x20u,	0x00u,	0xFFu,	0xD8u,	0x07u,	0x02u,	0x00u,
+	0xFDu,	0xA5u,	0x08u,	0x20u,	0x00u,	0x00u,	0x00u,	0x00u,	0xE2u,	0x00u,
+	0xFDu,	0xADu,	0x08u,	0x20u,	0x00u,	0x00u,	0x08u,	0x00u,	0xE2u,	0x00u,
+	0xFDu,	0x25u,	0x08u,	0x20u,	0x00u,	0x00u,	0x10u,	0x00u,	0xE2u,	0x00u,
+	0xFDu,	0x2Du,	0x08u,	0x20u,	0x00u,	0x00u,	0x18u,	0x00u,	0xE2u,	0x00u,
+	0xFFu,	0xE8u,	0x08u,	0x20u,	0x00u,	0x00u,	0x20u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x45u,	0x1Fu,	0x20u,	0x00u,	0x00u,	0x35u,	0x08u,	0x22u,	0x00u,
+	0x00u,	0x00u,	0x0Au,	0xA0u,	0x00u,	0xFFu,	0xE5u,	0x18u,	0x22u,	0x00u,
+	0x00u,	0x00u,	0x09u,	0xA0u,	0x00u,	0x00u,	0x38u,	0x00u,	0xEAu,	0x00u,
+	0x00u,	0x48u,	0x00u,	0xF2u,	0x00u,	0x00u,	0x38u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0xECu,	0x01u,	0x21u,	0x00u,	0x00u,	0x04u,	0x00u,	0xA1u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFFu,	0xE5u,	0x08u,	0x22u,	0x40u,
+	0x00u,	0x50u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x48u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x57u,	0xFFu,	0x20u,	0x00u,
+	0xFFu,	0xE5u,	0x08u,	0x22u,	0x00u,	0x00u,	0x58u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x58u,	0x0Bu,	0x20u,	0x00u,	0x00u,	0x28u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x85u,	0x1Fu,	0x20u,	0x00u,	0x00u,	0x75u,	0x08u,	0x22u,	0x00u,
+	0x00u,	0x00u,	0x0Du,	0xA0u,	0x00u,	0xFFu,	0xE5u,	0x18u,	0x22u,	0x00u,
+	0x00u,	0x00u,	0x0Cu,	0xA0u,	0x00u,	0x00u,	0x78u,	0x00u,	0xEAu,	0x00u,
+	0x00u,	0x88u,	0x00u,	0xF2u,	0x00u,	0x00u,	0x78u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0xECu,	0x01u,	0x21u,	0x00u,	0x00u,	0x04u,	0x00u,	0xA1u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFFu,	0xE5u,	0x08u,	0x22u,	0x40u,
+	0x00u,	0x50u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x88u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x57u,	0xFFu,	0x20u,	0x00u,
+	0xFFu,	0xE5u,	0x08u,	0x22u,	0x00u,	0x00u,	0x58u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x58u,	0x0Eu,	0x20u,	0x00u,	0x00u,	0x68u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x25u,	0x08u,	0x20u,	0x00u,	0xFFu,	0xD8u,	0x0Fu,	0x02u,	0x00u,
+	0x00u,	0x90u,	0x00u,	0xE2u,	0x00u,	0xFFu,	0xE8u,	0x10u,	0x20u,	0x00u,
+	0x00u,	0xE0u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x6Du,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xA8u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x6Du,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xC0u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x05u,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xB0u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x0Du,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xC8u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x15u,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xB8u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x1Du,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xD0u,	0x00u,	0xE2u,	0x00u,	0xFFu,	0xF5u,	0x08u,	0x20u,	0x00u,
+	0x01u,	0x38u,	0x00u,	0xE2u,	0x00u,	0x00u,	0xDDu,	0x08u,	0x20u,	0x00u,
+	0x00u,	0xE5u,	0x08u,	0x22u,	0x48u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFFu,	0xEDu,	0x08u,	0x20u,	0x26u,	0x01u,	0x38u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0xFDu,	0x08u,	0x20u,	0x00u,	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,
+	0x00u,	0xDDu,	0x08u,	0x20u,	0x00u,	0x01u,	0x1Du,	0x08u,	0x20u,	0x25u,
+	0x01u,	0x20u,	0x00u,	0xE2u,	0x00u,	0x01u,	0x0Du,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,	0x00u,	0xDDu,	0x08u,	0x20u,	0x00u,
+	0x01u,	0x2Du,	0x08u,	0x20u,	0x25u,	0x01u,	0x30u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x45u,	0x08u,	0x20u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x01u,	0x50u,	0x00u,	0xF0u,	0x00u,	0x01u,	0x55u,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,	0x01u,	0x3Du,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xF5u,	0x08u,	0x20u,	0x25u,	0x01u,	0x38u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0xDDu,	0x08u,	0x20u,	0x00u,	0x00u,	0xE0u,	0x00u,	0xE2u,	0x25u,
+	0x00u,	0xEDu,	0x08u,	0x20u,	0x00u,	0x00u,	0xFDu,	0x08u,	0x22u,	0x40u,
+	0x01u,	0x48u,	0x00u,	0xE2u,	0x00u,	0x00u,	0xFDu,	0x08u,	0x20u,	0x00u,
+	0x01u,	0x4Du,	0x14u,	0x22u,	0x00u,	0x01u,	0x00u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x20u,	0x00u,	0xC0u,	0x00u,	0x00u,	0x07u,	0xFFu,	0xA0u,	0x00u,
+	0x01u,	0x00u,	0x00u,	0xC0u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0xAFu,	0xFFu,	0x20u,	0x80u,	0x00u,	0x98u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0xC7u,	0xFFu,	0x40u,	0x80u,	0x00u,	0xA0u,	0x00u,	0xE4u,	0x00u,
+	0xFFu,	0xEDu,	0x08u,	0x20u,	0x00u,	0xFFu,	0xEFu,	0xFFu,	0x22u,	0x40u,
+	0x01u,	0x10u,	0x00u,	0xE2u,	0x00u,	0x01u,	0x30u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x07u,	0xFFu,	0xA0u,	0x00u,	0x01u,	0x10u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xAFu,	0xFFu,	0x20u,	0x80u,
+	0x00u,	0x9Du,	0x08u,	0x22u,	0x00u,	0x00u,	0x98u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0xC7u,	0xFFu,	0x40u,	0x80u,	0x00u,	0xA5u,	0x08u,	0x44u,	0x00u,
+	0x00u,	0xA0u,	0x00u,	0xE4u,	0x00u,	0x00u,	0xEDu,	0x08u,	0x20u,	0x00u,
+	0x01u,	0x3Du,	0x08u,	0x22u,	0x40u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0xF0u,	0x00u,	0xF0u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x01u,	0x7Du,	0x08u,	0x20u,	0x00u,	0xFFu,	0xE8u,	0x12u,	0x34u,	0x00u,
+	0x01u,	0x6Du,	0x08u,	0x22u,	0x48u,	0x01u,	0x78u,	0x11u,	0x20u,	0x40u,
+	0x01u,	0x68u,	0x11u,	0x34u,	0x40u,	0x01u,	0x78u,	0x11u,	0x20u,	0x25u,
+	0x01u,	0x68u,	0x11u,	0x34u,	0x25u,	0x01u,	0x90u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x88u,	0x00u,	0xF2u,	0x00u,	0x01u,	0x7Du,	0x08u,	0x20u,	0x00u,
+	0x01u,	0x8Du,	0x08u,	0x22u,	0x00u,	0x01u,	0x6Du,	0x08u,	0x34u,	0x00u,
+	0x01u,	0x95u,	0x08u,	0x22u,	0x00u,	0x01u,	0x70u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x80u,	0x00u,	0xF2u,	0x00u,	0x01u,	0x75u,	0x08u,	0x20u,	0x08u,
+	0xFFu,	0xEDu,	0x1Fu,	0x20u,	0x00u,	0x01u,	0x75u,	0x08u,	0x20u,	0x25u,
+	0x01u,	0x70u,	0x00u,	0xE2u,	0x00u,	0xFFu,	0xEDu,	0x1Fu,	0x22u,	0x40u,
+	0x01u,	0xA0u,	0x00u,	0xE2u,	0x00u,	0x01u,	0x75u,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xE8u,	0x12u,	0x22u,	0x40u,	0x01u,	0x70u,	0x11u,	0x30u,	0x48u,
+	0x01u,	0xA5u,	0x08u,	0x20u,	0x00u,	0xFFu,	0xE8u,	0x12u,	0x20u,	0x27u,
+	0x01u,	0xA0u,	0x00u,	0xE2u,	0x00u,	0x01u,	0xA0u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x17u,	0xFFu,	0x20u,	0x00u,	0x01u,	0x58u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x1Fu,	0xFFu,	0x20u,	0x00u,	0x01u,	0x60u,	0x00u,	0xE2u,	0x00u,
+	0xFFu,	0xE8u,	0x13u,	0x20u,	0x00u,	0x01u,	0xF0u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x05u,	0x08u,	0x20u,	0x00u,	0x01u,	0xB8u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x0Du,	0x08u,	0x20u,	0x00u,	0x01u,	0xD0u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x5Du,	0x08u,	0x20u,	0x00u,	0x01u,	0xC0u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0x65u,	0x08u,	0x20u,	0x00u,	0x01u,	0xD8u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x2Du,	0x08u,	0x20u,	0x00u,	0x01u,	0xC8u,	0x00u,	0xE2u,	0x00u,
+	0x00u,	0x2Du,	0x08u,	0x20u,	0x00u,	0x01u,	0xE0u,	0x00u,	0xE2u,	0x00u,
+	0xFFu,	0xF5u,	0x08u,	0x20u,	0x00u,	0x02u,	0x48u,	0x00u,	0xE2u,	0x00u,
+	0x01u,	0xEDu,	0x08u,	0x20u,	0x00u,	0x01u,	0xF5u,	0x08u,	0x22u,	0x48u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFFu,	0xEDu,	0x08u,	0x20u,	0x26u,
+	0x02u,	0x48u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x0Du,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,	0x01u,	0xEDu,	0x08u,	0x20u,	0x00u,
+	0x02u,	0x2Du,	0x08u,	0x20u,	0x25u,	0x02u,	0x30u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0x1Du,	0x08u,	0x20u,	0x00u,	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,
+	0x01u,	0xEDu,	0x08u,	0x20u,	0x00u,	0x02u,	0x3Du,	0x08u,	0x20u,	0x25u,
+	0x02u,	0x40u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x55u,	0x08u,	0x20u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x02u,	0x60u,	0x00u,	0xF0u,	0x00u,
+	0x02u,	0x65u,	0x08u,	0x20u,	0x00u,	0xFFu,	0xEDu,	0x13u,	0x22u,	0x48u,
+	0x02u,	0x4Du,	0x08u,	0x20u,	0x00u,	0xFFu,	0xF5u,	0x08u,	0x20u,	0x25u,
+	0x02u,	0x48u,	0x00u,	0xE2u,	0x00u,	0x01u,	0xEDu,	0x08u,	0x20u,	0x00u,
+	0x01u,	0xF0u,	0x00u,	0xE2u,	0x25u,	0x01u,	0xFDu,	0x08u,	0x20u,	0x00u,
+	0x02u,	0x0Du,	0x08u,	0x22u,	0x40u,	0x02u,	0x58u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0x0Du,	0x08u,	0x20u,	0x00u,	0x02u,	0x5Du,	0x14u,	0x22u,	0x00u,
+	0x02u,	0x10u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x30u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x07u,	0xFFu,	0xA0u,	0x00u,	0x02u,	0x10u,	0x00u,	0xC0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x01u,	0xBFu,	0xFFu,	0x20u,	0x80u,
+	0x01u,	0xA8u,	0x00u,	0xE2u,	0x00u,	0x01u,	0xD7u,	0xFFu,	0x40u,	0x80u,
+	0x01u,	0xB0u,	0x00u,	0xE4u,	0x00u,	0xFFu,	0xEDu,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xEFu,	0xFFu,	0x22u,	0x40u,	0x02u,	0x20u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0x40u,	0x00u,	0xC0u,	0x00u,	0x00u,	0x07u,	0xFFu,	0xA0u,	0x00u,
+	0x02u,	0x20u,	0x00u,	0xC0u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x01u,	0xBFu,	0xFFu,	0x20u,	0x80u,	0x01u,	0xADu,	0x08u,	0x22u,	0x00u,
+	0x01u,	0xA8u,	0x00u,	0xE2u,	0x00u,	0x01u,	0xD7u,	0xFFu,	0x40u,	0x80u,
+	0x01u,	0xB5u,	0x08u,	0x44u,	0x00u,	0x01u,	0xB0u,	0x00u,	0xE4u,	0x00u,
+	0x01u,	0xFDu,	0x08u,	0x20u,	0x00u,	0x02u,	0x4Du,	0x08u,	0x22u,	0x40u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x02u,	0x00u,	0x00u,	0xF0u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x02u,	0x8Du,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xE8u,	0x15u,	0x34u,	0x00u,	0x02u,	0x7Du,	0x08u,	0x22u,	0x48u,
+	0x02u,	0x88u,	0x14u,	0x20u,	0x40u,	0x02u,	0x78u,	0x14u,	0x34u,	0x40u,
+	0x02u,	0x88u,	0x14u,	0x20u,	0x25u,	0x02u,	0x78u,	0x14u,	0x34u,	0x25u,
+	0x02u,	0xA0u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x98u,	0x00u,	0xF2u,	0x00u,
+	0x02u,	0x8Du,	0x08u,	0x20u,	0x00u,	0x02u,	0x9Du,	0x08u,	0x22u,	0x00u,
+	0x02u,	0x7Du,	0x08u,	0x34u,	0x00u,	0x02u,	0xA5u,	0x08u,	0x22u,	0x00u,
+	0x02u,	0x80u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x90u,	0x00u,	0xF2u,	0x00u,
+	0x02u,	0x85u,	0x08u,	0x20u,	0x08u,	0xFFu,	0xEDu,	0x1Fu,	0x20u,	0x00u,
+	0x02u,	0x85u,	0x08u,	0x20u,	0x25u,	0x02u,	0x80u,	0x00u,	0xE2u,	0x00u,
+	0xFFu,	0xEDu,	0x1Fu,	0x22u,	0x40u,	0x02u,	0xB0u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0x85u,	0x08u,	0x20u,	0x00u,	0xFFu,	0xE8u,	0x15u,	0x22u,	0x40u,
+	0x02u,	0x80u,	0x14u,	0x30u,	0x48u,	0x02u,	0xB5u,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xE8u,	0x15u,	0x20u,	0x27u,	0x02u,	0xB0u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0xB0u,	0x00u,	0xC0u,	0x00u,	0x00u,	0x9Fu,	0xFFu,	0x20u,	0x00u,
+	0x02u,	0x68u,	0x00u,	0xE2u,	0x00u,	0x00u,	0xA7u,	0xFFu,	0x20u,	0x00u,
+	0x02u,	0x70u,	0x00u,	0xE2u,	0x00u,	0x02u,	0xDDu,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xE8u,	0x17u,	0x34u,	0x00u,	0x02u,	0xCDu,	0x08u,	0x22u,	0x48u,
+	0x02u,	0xD8u,	0x16u,	0x20u,	0x40u,	0x02u,	0xC8u,	0x16u,	0x34u,	0x40u,
+	0x02u,	0xD8u,	0x16u,	0x20u,	0x25u,	0x02u,	0xC8u,	0x16u,	0x34u,	0x25u,
+	0x02u,	0xF0u,	0x00u,	0xE2u,	0x00u,	0x02u,	0xE8u,	0x00u,	0xF2u,	0x00u,
+	0x02u,	0xDDu,	0x08u,	0x20u,	0x00u,	0x02u,	0xEDu,	0x08u,	0x22u,	0x00u,
+	0x02u,	0xCDu,	0x08u,	0x34u,	0x00u,	0x02u,	0xF5u,	0x08u,	0x22u,	0x00u,
+	0x02u,	0xD0u,	0x00u,	0xE2u,	0x00u,	0x02u,	0xE0u,	0x00u,	0xF2u,	0x00u,
+	0x02u,	0xD5u,	0x08u,	0x20u,	0x08u,	0xFFu,	0xEDu,	0x1Fu,	0x20u,	0x00u,
+	0x02u,	0xD5u,	0x08u,	0x20u,	0x25u,	0x02u,	0xD0u,	0x00u,	0xE2u,	0x00u,
+	0xFFu,	0xEDu,	0x1Fu,	0x22u,	0x40u,	0x03u,	0x00u,	0x00u,	0xE2u,	0x00u,
+	0x02u,	0xD5u,	0x08u,	0x20u,	0x00u,	0xFFu,	0xE8u,	0x17u,	0x22u,	0x40u,
+	0x02u,	0xD0u,	0x16u,	0x30u,	0x48u,	0x03u,	0x05u,	0x08u,	0x20u,	0x00u,
+	0xFFu,	0xE8u,	0x17u,	0x20u,	0x27u,	0x03u,	0x00u,	0x00u,	0xE2u,	0x00u,
+	0x03u,	0x00u,	0x00u,	0xC0u,	0x00u,	0x01u,	0xAFu,	0xFFu,	0x20u,	0x00u,
+	0x02u,	0xB8u,	0x00u,	0xE2u,	0x00u,	0x01u,	0xB7u,	0xFFu,	0x20u,	0x00u,
+	0x02u,	0xC0u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x6Du,	0x08u,	0x20u,	0x00u,
+	0xFDu,	0x60u,	0x00u,	0xE2u,	0x00u,	0x02u,	0x75u,	0x08u,	0x20u,	0x00u,
+	0xFDu,	0x68u,	0x00u,	0xE2u,	0x00u,	0x02u,	0xC5u,	0x08u,	0x20u,	0x00u,
+	0xFDu,	0xB8u,	0x00u,	0xE2u,	0x00u,	0x02u,	0xBDu,	0x08u,	0x20u,	0x00u,
+	0xFDu,	0xB0u,	0x00u,	0xE2u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFEu,	0x30u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0xFEu,	0xC0u,	0x0Fu,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u
+
+};
+
+static unsigned char gaConfig_ADAU1761_Param_Data29[96] =
+{
+	0x00u,	0x00u,	0x10u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x02u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0xFFu,
+	0x00u,	0x02u,	0x22u,	0x26u,	0x00u,	0x80u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x00u,	0xFFu,	0x00u,	0x02u,	0x22u,	0x26u,	0x00u,	0x80u,	0x00u,	0x00u,
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x01u,	0x00u,	0x00u,
+	0x10u,	0x00u,	0x00u,	0x80u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x01u,
+	0x00u,	0x00u,	0x10u,	0x00u,	0x00u,	0x80u,	0x00u,	0x00u,	0x00u,	0x00u,
+	0x10u,	0x00u,	0x00u,	0x80u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_PLLCrlRegister_Data30[6] =
+{
+	0x00u,	0x00u,	0x00u,	0x00u,	0x00u,	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_SampleRate_Data31[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_ADAU1761_DSPRun_Data32[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_ADAU1761_DejitterRegister_Data33[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_ADAU1761_DejitterRegister_Data34[1] =
+{
+	0x03u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADRDisable_Data26[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data27[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_BCDNSLOTS_Data5[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_LDNSLOTS_Data6[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_LUPSLOTS_Data7[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2CCFG_Data8[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_SYNCOFFSET_Data9[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2SGCFG_Data10[1] =
+{
+	0xE0u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2SCFG_Data11[1] =
+{
+	0x20u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2SRATE_Data12[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_PDMCTL_Data13[1] =
+{
+	0x18u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_ERRMGMT_Data14[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIODAT_Data15[1] =
+{
+	0x10u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOOEN_Data16[1] =
+{
+	0x10u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOIEN_Data17[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_PINTEN_Data18[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_PINTINV_Data19[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_PINCFG_Data20[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_TESTMODE_Data21[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_CLK1CFG_Data22[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_CLK2CFG_Data23[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPMASK0_Data24[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPMASK1_Data25[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPMASK2_Data26[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPMASK3_Data27[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPOFFSET_Data28[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNMASK0_Data29[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNMASK1_Data30[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNMASK2_Data31[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNMASK3_Data32[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNOFFSET_Data33[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD0MSK_Data34[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD1MSK_Data35[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD2MSK_Data36[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD3MSK_Data37[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD4MSK_Data38[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD5MSK_Data39[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD6MSK_Data40[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIOD7MSK_Data41[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIODINV_Data42[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_GPIODEN_Data43[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_MBOX0CTL_Data44[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_MBOX1CTL_Data45[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_SUSCFG_Data46[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2SRRSOFFS_Data47[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_I2SRRCTL_Data48[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_INTMSK0_Data49[1] =
+{
+	0x77u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_INTMSK1_Data50[1] =
+{
+	0x7Fu
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_BECCTL_Data51[1] =
+{
+	0xEFu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADRSet_Data28[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2CCFG_Data29[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2SCFG_Data30[1] =
+{
+	0x99u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2STXOFFSET_Data31[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2SRXOFFSET_Data32[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_PDMCTL_Data33[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_ERRMGMT_Data34[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIODAT_Data35[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOOEN_Data36[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOIEN_Data37[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_PINTEN_Data38[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_PINTINV_Data39[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_PINCFG_Data40[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_TESTMODE_Data41[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_CLK1CFG_Data42[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_CLK2CFG_Data43[1] =
+{
+	0x81u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD0MSK_Data44[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD1MSK_Data45[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD2MSK_Data46[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD3MSK_Data47[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD4MSK_Data48[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD5MSK_Data49[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD6MSK_Data50[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIOD7MSK_Data51[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIODINV_Data52[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_GPIODEN_Data53[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2SRRCTL_Data54[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_BECCTL_Data55[1] =
+{
+	0xEFu
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data56[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_DNSLOTS_Data52[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_UPSLOTS_Data53[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_DNSLOTS_Data57[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_UPSLOTS_Data58[1] =
+{
+	0x02u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data59[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BSlaveNode0WCZ_SWCTL_Data54[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data60[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data61[1] =
+{
+	0x00u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_SLOTFMT_Data62[1] =
+{
+	0x44u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_DATCTL_Data63[1] =
+{
+	0x03u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_I2SRRATE_Data64[1] =
+{
+	0x01u
+};
+
+static unsigned char gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data65[1] =
+{
+	0x01u
+};
+
+ADI_A2B_DISCOVERY_CONFIG gaA2BConfig[CONFIG_LEN] =
+{
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000012u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data0[0]},	/* CONTROL */
+	{0x68u,	DELAY,	0x01u,	0x00000000u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data1[0]},	/* A2B_Delay */
+	{0x68u,	READ,	0x01u,	0x00000017u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTTYPE_Data2[0]},	/* INTTYPE */
+	{0x68u,	WRITE,	0x01u,	0x0000001Bu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTMSK0_Data3[0]},	/* INTMSK0 */
+	{0x68u,	WRITE,	0x01u,	0x0000001Cu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTMSK1_Data4[0]},	/* INTMSK1 */
+	{0x68u,	WRITE,	0x01u,	0x0000001Du,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTMSK2_Data5[0]},	/* INTMSK2 */
+	{0x68u,	WRITE,	0x01u,	0x0000000Fu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_RESPCYCS_Data6[0]},	/* RESPCYCS */
+	{0x68u,	WRITE,	0x01u,	0x00000012u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data7[0]},	/* CONTROL */
+	{0x68u,	WRITE,	0x01u,	0x00000041u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2SGCFG_Data8[0]},	/* I2SGCFG */
+	{0x68u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data9[0]},	/* SWCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000013u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_DISCVRY_Data10[0]},	/* DISCVRY */
+	{0x68u,	DELAY,	0x01u,	0x00000000u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data11[0]},	/* A2B_Delay */
+	{0x68u,	READ,	0x01u,	0x0000001Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data12[0]},	/* INTPND2 */
+	{0x68u,	WRITE,	0x01u,	0x0000001Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data13[0]},	/* INTPND2 */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data14[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	READ,	0x01u,	0x00000002u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_VENDOR_Data0[0]},	/* VENDOR */
+	{0x69u,	READ,	0x01u,	0x00000003u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_PRODUCT_Data1[0]},	/* PRODUCT */
+	{0x69u,	READ,	0x01u,	0x00000004u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_VERSION_Data2[0]},	/* VERSION */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data15[0]},	/* SWCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data16[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_SWCTL_Data3[0]},	/* SWCTL */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000013u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_DISCVRY_Data17[0]},	/* DISCVRY */
+	{0x68u,	DELAY,	0x01u,	0x00000000u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_A2BDelay_Data18[0]},	/* A2B_Delay */
+	{0x68u,	READ,	0x01u,	0x0000001Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data19[0]},	/* INTPND2 */
+	{0x68u,	WRITE,	0x01u,	0x0000001Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_INTPND2_Data20[0]},	/* INTPND2 */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data21[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node1 WBZ  --*/
+	{0x69u,	READ,	0x01u,	0x00000002u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_VENDOR_Data0[0]},	/* VENDOR */
+	{0x69u,	READ,	0x01u,	0x00000003u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_PRODUCT_Data1[0]},	/* PRODUCT */
+	{0x69u,	READ,	0x01u,	0x00000004u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_VERSION_Data2[0]},	/* VERSION */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data22[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_SWCTL_Data4[0]},	/* SWCTL */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data23[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node1 WBZ  --*/
+	{0x69u,	WRITE,	0x01u,	0x0000000Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_BCDNSLOTS_Data3[0]},	/* BCDNSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000000Bu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_LDNSLOTS_Data4[0]},	/* LDNSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000000Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_LUPSLOTS_Data5[0]},	/* LUPSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000003Fu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2CCFG_Data6[0]},	/* I2CCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000046u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_SYNCOFFSET_Data7[0]},	/* SYNCOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000041u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2SGCFG_Data8[0]},	/* I2SGCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000042u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2SCFG_Data9[0]},	/* I2SCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000043u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2SRATE_Data10[0]},	/* I2SRATE */
+	{0x69u,	WRITE,	0x01u,	0x00000047u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_PDMCTL_Data11[0]},	/* PDMCTL */
+	{0x69u,	WRITE,	0x01u,	0x00000048u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_ERRMGMT_Data12[0]},	/* ERRMGMT */
+	{0x69u,	WRITE,	0x01u,	0x0000004Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIODAT_Data13[0]},	/* GPIODAT */
+	{0x69u,	WRITE,	0x01u,	0x0000004Du,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOOEN_Data14[0]},	/* GPIOOEN */
+	{0x69u,	WRITE,	0x01u,	0x0000004Eu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOIEN_Data15[0]},	/* GPIOIEN */
+	{0x69u,	WRITE,	0x01u,	0x00000050u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_PINTEN_Data16[0]},	/* PINTEN */
+	{0x69u,	WRITE,	0x01u,	0x00000051u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_PINTINV_Data17[0]},	/* PINTINV */
+	{0x69u,	WRITE,	0x01u,	0x00000052u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_PINCFG_Data18[0]},	/* PINCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000020u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_TESTMODE_Data19[0]},	/* TESTMODE */
+	{0x69u,	WRITE,	0x01u,	0x00000059u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_CLK1CFG_Data20[0]},	/* CLK1CFG */
+	{0x69u,	WRITE,	0x01u,	0x0000005Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_CLK2CFG_Data21[0]},	/* CLK2CFG */
+	{0x69u,	WRITE,	0x01u,	0x00000060u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_UPMASK0_Data22[0]},	/* UPMASK0 */
+	{0x69u,	WRITE,	0x01u,	0x00000061u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_UPMASK1_Data23[0]},	/* UPMASK1 */
+	{0x69u,	WRITE,	0x01u,	0x00000062u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_UPMASK2_Data24[0]},	/* UPMASK2 */
+	{0x69u,	WRITE,	0x01u,	0x00000063u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_UPMASK3_Data25[0]},	/* UPMASK3 */
+	{0x69u,	WRITE,	0x01u,	0x00000064u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_UPOFFSET_Data26[0]},	/* UPOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000065u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_DNMASK0_Data27[0]},	/* DNMASK0 */
+	{0x69u,	WRITE,	0x01u,	0x00000066u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_DNMASK1_Data28[0]},	/* DNMASK1 */
+	{0x69u,	WRITE,	0x01u,	0x00000067u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_DNMASK2_Data29[0]},	/* DNMASK2 */
+	{0x69u,	WRITE,	0x01u,	0x00000068u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_DNMASK3_Data30[0]},	/* DNMASK3 */
+	{0x69u,	WRITE,	0x01u,	0x00000069u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_DNOFFSET_Data31[0]},	/* DNOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000081u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD0MSK_Data32[0]},	/* GPIOD0MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000082u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD1MSK_Data33[0]},	/* GPIOD1MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000083u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD2MSK_Data34[0]},	/* GPIOD2MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000084u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD3MSK_Data35[0]},	/* GPIOD3MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000085u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD4MSK_Data36[0]},	/* GPIOD4MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000086u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD5MSK_Data37[0]},	/* GPIOD5MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000087u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD6MSK_Data38[0]},	/* GPIOD6MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000088u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIOD7MSK_Data39[0]},	/* GPIOD7MSK */
+	{0x69u,	WRITE,	0x01u,	0x0000008Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIODINV_Data40[0]},	/* GPIODINV */
+	{0x69u,	WRITE,	0x01u,	0x00000080u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_GPIODEN_Data41[0]},	/* GPIODEN */
+	{0x69u,	WRITE,	0x01u,	0x00000090u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_MBOX0CTL_Data42[0]},	/* MBOX0CTL */
+	{0x69u,	WRITE,	0x01u,	0x00000096u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_MBOX1CTL_Data43[0]},	/* MBOX1CTL */
+	{0x69u,	WRITE,	0x01u,	0x0000005Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_SUSCFG_Data44[0]},	/* SUSCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000058u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2SRRSOFFS_Data45[0]},	/* I2SRRSOFFS */
+	{0x69u,	WRITE,	0x01u,	0x00000057u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_I2SRRCTL_Data46[0]},	/* I2SRRCTL */
+	{0x69u,	WRITE,	0x01u,	0x0000001Bu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_INTMSK0_Data47[0]},	/* INTMSK0 */
+	{0x69u,	WRITE,	0x01u,	0x0000001Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_INTMSK1_Data48[0]},	/* INTMSK1 */
+	{0x69u,	WRITE,	0x01u,	0x0000001Eu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_BECCTL_Data49[0]},	/* BECCTL */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADRSet_Data24[0]},	/* NODEADR - Set the node address */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node1 WBZ  --*/
+	{0x69u,	WRITE,	0x01u,	0x00000000u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode1WBZ_CHIPSet_Data50[0]},	/* CHIP - Set the chip address */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADREnable_Data25[0]},	/* NODEADR - Enable PERI */
+
+	/*-- COMMANDS FOR DEVICE - ADAU1761 --*/
+	{0x69u,	WRITE,	0x02u,	0x000040EBu,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SampleRate_Data0[0]},	/* IC 1.Sample Rate Setting */
+	{0x69u,	WRITE,	0x02u,	0x000040F6u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DSPRun_Data1[0]},	/* IC 1.DSP Run Register */
+	{0x69u,	WRITE,	0x02u,	0x00004000u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_ClockControl_Data2[0]},	/* IC 1.Clock Control Register */
+	{0x69u,	WRITE,	0x02u,	0x00004002u,	0x01u,	0x0006u,	&gaConfig_ADAU1761_PLLControl_Data3[0]},	/* IC 1.PLL Control Register */
+	{0x69u,	DELAY,	0x02u,	0x00000000u,	0x01u,	0x0002u,	&gaConfig_ADAU1761_Delay_Data4[0]},	/* IC 1.Delay */
+	{0x69u,	WRITE,	0x02u,	0x00004015u,	0x01u,	0x0002u,	&gaConfig_ADAU1761_SerialPort_Data5[0]},	/* IC 1.Serial Port Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x00004011u,	0x01u,	0x0004u,	&gaConfig_ADAU1761_ALCControl_Data6[0]},	/* IC 1.ALC Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x00004008u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_MicrophoneControl_Data7[0]},	/* IC 1.Microphone Control Register */
+	{0x69u,	WRITE,	0x02u,	0x00004009u,	0x01u,	0x0008u,	&gaConfig_ADAU1761_RecordInput_Data8[0]},	/* IC 1.Record Input Signal Path Registers */
+	{0x69u,	WRITE,	0x02u,	0x00004019u,	0x01u,	0x0003u,	&gaConfig_ADAU1761_ADCControl_Data9[0]},	/* IC 1.ADC Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x0000401Cu,	0x01u,	0x000Eu,	&gaConfig_ADAU1761_PlaybackOutput_Data10[0]},	/* IC 1.Playback Output Signal Path Registers */
+	{0x69u,	WRITE,	0x02u,	0x00004017u,	0x01u,	0x0002u,	&gaConfig_ADAU1761_ConverterControl_Data11[0]},	/* IC 1.Converter Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x0000402Au,	0x01u,	0x0003u,	&gaConfig_ADAU1761_DACControl_Data12[0]},	/* IC 1.DAC Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x0000402Du,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SerialPort_Data13[0]},	/* IC 1.Serial Port Pad Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x0000402Fu,	0x01u,	0x0002u,	&gaConfig_ADAU1761_CommunicationPort_Data14[0]},	/* IC 1.Communication Port Pad Control Registers */
+	{0x69u,	WRITE,	0x02u,	0x00004031u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_JackDetect_Data15[0]},	/* IC 1.Jack Detect Pad Control Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F5u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DSPON_Data16[0]},	/* IC 1.DSP ON Register */
+	{0x69u,	WRITE,	0x02u,	0x000040C0u,	0x01u,	0x0005u,	&gaConfig_ADAU1761_CRCRegisters_Data17[0]},	/* IC 1.CRC Registers */
+	{0x69u,	WRITE,	0x02u,	0x000040C6u,	0x01u,	0x0004u,	&gaConfig_ADAU1761_GPIORegisters_Data18[0]},	/* IC 1.GPIO Registers */
+	{0x69u,	WRITE,	0x02u,	0x000040E9u,	0x01u,	0x0002u,	&gaConfig_ADAU1761_NonModulo_Data19[0]},	/* IC 1.Non Modulo Registers */
+	{0x69u,	WRITE,	0x02u,	0x000040D0u,	0x01u,	0x0005u,	&gaConfig_ADAU1761_WatchdogRegisters_Data20[0]},	/* IC 1.Watchdog Registers */
+	{0x69u,	WRITE,	0x02u,	0x000040EBu,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SamplingRate_Data21[0]},	/* IC 1.Sampling Rate Setting Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F2u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_RoutingMatrix_Data22[0]},	/* IC 1.Routing Matrix Inputs Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F3u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_RoutingMatrix_Data23[0]},	/* IC 1.Routing Matrix Outputs Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F4u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SerialData_Data24[0]},	/* IC 1.Serial Data Configuration Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F7u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DSPSlew_Data25[0]},	/* IC 1.DSP Slew Mode Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F8u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SerialPort_Data26[0]},	/* IC 1.Serial Port Sample Rate Register */
+	{0x69u,	WRITE,	0x02u,	0x000040F9u,	0x01u,	0x0002u,	&gaConfig_ADAU1761_ClockEnable_Data27[0]},	/* IC 1.Clock Enable Registers */
+	{0x69u,	WRITE,	0x02u,	0x00000800u,	0x01u,	0x06C2u,	&gaConfig_ADAU1761_ProgramData_Data28[0]},	/* Program Data */
+	{0x69u,	WRITE,	0x02u,	0x00000000u,	0x01u,	0x0060u,	&gaConfig_ADAU1761_Param_Data29[0]},	/* Param */
+	{0x69u,	READ,	0x02u,	0x00004002u,	0x01u,	0x0006u,	&gaConfig_ADAU1761_PLLCrlRegister_Data30[0]},	/* IC 1.PLLCrlRegister */
+	{0x69u,	WRITE,	0x02u,	0x000040EBu,	0x01u,	0x0001u,	&gaConfig_ADAU1761_SampleRate_Data31[0]},	/* IC 1.Sample Rate Setting */
+	{0x69u,	WRITE,	0x02u,	0x000040F6u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DSPRun_Data32[0]},	/* IC 1.DSP Run Register */
+	{0x69u,	WRITE,	0x02u,	0x00004036u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DejitterRegister_Data33[0]},	/* IC 1.Dejitter Register Control */
+	{0x69u,	WRITE,	0x02u,	0x00004036u,	0x01u,	0x0001u,	&gaConfig_ADAU1761_DejitterRegister_Data34[0]},	/* IC 1.Dejitter Register Control */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADRDisable_Data26[0]},	/* NODEADR - Disable PERI */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data27[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	WRITE,	0x01u,	0x0000000Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_BCDNSLOTS_Data5[0]},	/* BCDNSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000000Bu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_LDNSLOTS_Data6[0]},	/* LDNSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000000Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_LUPSLOTS_Data7[0]},	/* LUPSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000003Fu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2CCFG_Data8[0]},	/* I2CCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000046u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_SYNCOFFSET_Data9[0]},	/* SYNCOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000041u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2SGCFG_Data10[0]},	/* I2SGCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000042u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2SCFG_Data11[0]},	/* I2SCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000043u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2SRATE_Data12[0]},	/* I2SRATE */
+	{0x69u,	WRITE,	0x01u,	0x00000047u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_PDMCTL_Data13[0]},	/* PDMCTL */
+	{0x69u,	WRITE,	0x01u,	0x00000048u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_ERRMGMT_Data14[0]},	/* ERRMGMT */
+	{0x69u,	WRITE,	0x01u,	0x0000004Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIODAT_Data15[0]},	/* GPIODAT */
+	{0x69u,	WRITE,	0x01u,	0x0000004Du,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOOEN_Data16[0]},	/* GPIOOEN */
+	{0x69u,	WRITE,	0x01u,	0x0000004Eu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOIEN_Data17[0]},	/* GPIOIEN */
+	{0x69u,	WRITE,	0x01u,	0x00000050u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_PINTEN_Data18[0]},	/* PINTEN */
+	{0x69u,	WRITE,	0x01u,	0x00000051u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_PINTINV_Data19[0]},	/* PINTINV */
+	{0x69u,	WRITE,	0x01u,	0x00000052u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_PINCFG_Data20[0]},	/* PINCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000020u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_TESTMODE_Data21[0]},	/* TESTMODE */
+	{0x69u,	WRITE,	0x01u,	0x00000059u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_CLK1CFG_Data22[0]},	/* CLK1CFG */
+	{0x69u,	WRITE,	0x01u,	0x0000005Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_CLK2CFG_Data23[0]},	/* CLK2CFG */
+	{0x69u,	WRITE,	0x01u,	0x00000060u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPMASK0_Data24[0]},	/* UPMASK0 */
+	{0x69u,	WRITE,	0x01u,	0x00000061u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPMASK1_Data25[0]},	/* UPMASK1 */
+	{0x69u,	WRITE,	0x01u,	0x00000062u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPMASK2_Data26[0]},	/* UPMASK2 */
+	{0x69u,	WRITE,	0x01u,	0x00000063u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPMASK3_Data27[0]},	/* UPMASK3 */
+	{0x69u,	WRITE,	0x01u,	0x00000064u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPOFFSET_Data28[0]},	/* UPOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000065u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNMASK0_Data29[0]},	/* DNMASK0 */
+	{0x69u,	WRITE,	0x01u,	0x00000066u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNMASK1_Data30[0]},	/* DNMASK1 */
+	{0x69u,	WRITE,	0x01u,	0x00000067u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNMASK2_Data31[0]},	/* DNMASK2 */
+	{0x69u,	WRITE,	0x01u,	0x00000068u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNMASK3_Data32[0]},	/* DNMASK3 */
+	{0x69u,	WRITE,	0x01u,	0x00000069u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNOFFSET_Data33[0]},	/* DNOFFSET */
+	{0x69u,	WRITE,	0x01u,	0x00000081u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD0MSK_Data34[0]},	/* GPIOD0MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000082u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD1MSK_Data35[0]},	/* GPIOD1MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000083u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD2MSK_Data36[0]},	/* GPIOD2MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000084u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD3MSK_Data37[0]},	/* GPIOD3MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000085u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD4MSK_Data38[0]},	/* GPIOD4MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000086u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD5MSK_Data39[0]},	/* GPIOD5MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000087u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD6MSK_Data40[0]},	/* GPIOD6MSK */
+	{0x69u,	WRITE,	0x01u,	0x00000088u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIOD7MSK_Data41[0]},	/* GPIOD7MSK */
+	{0x69u,	WRITE,	0x01u,	0x0000008Au,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIODINV_Data42[0]},	/* GPIODINV */
+	{0x69u,	WRITE,	0x01u,	0x00000080u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_GPIODEN_Data43[0]},	/* GPIODEN */
+	{0x69u,	WRITE,	0x01u,	0x00000090u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_MBOX0CTL_Data44[0]},	/* MBOX0CTL */
+	{0x69u,	WRITE,	0x01u,	0x00000096u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_MBOX1CTL_Data45[0]},	/* MBOX1CTL */
+	{0x69u,	WRITE,	0x01u,	0x0000005Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_SUSCFG_Data46[0]},	/* SUSCFG */
+	{0x69u,	WRITE,	0x01u,	0x00000058u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2SRRSOFFS_Data47[0]},	/* I2SRRSOFFS */
+	{0x69u,	WRITE,	0x01u,	0x00000057u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_I2SRRCTL_Data48[0]},	/* I2SRRCTL */
+	{0x69u,	WRITE,	0x01u,	0x0000001Bu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_INTMSK0_Data49[0]},	/* INTMSK0 */
+	{0x69u,	WRITE,	0x01u,	0x0000001Cu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_INTMSK1_Data50[0]},	/* INTMSK1 */
+	{0x69u,	WRITE,	0x01u,	0x0000001Eu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_BECCTL_Data51[0]},	/* BECCTL */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADRSet_Data28[0]},	/* NODEADR - Set the node address */
+	{0x68u,	WRITE,	0x01u,	0x0000003Fu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2CCFG_Data29[0]},	/* I2CCFG */
+	{0x68u,	WRITE,	0x01u,	0x00000042u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2SCFG_Data30[0]},	/* I2SCFG */
+	{0x68u,	WRITE,	0x01u,	0x00000044u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2STXOFFSET_Data31[0]},	/* I2STXOFFSET */
+	{0x68u,	WRITE,	0x01u,	0x00000045u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2SRXOFFSET_Data32[0]},	/* I2SRXOFFSET */
+	{0x68u,	WRITE,	0x01u,	0x00000047u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_PDMCTL_Data33[0]},	/* PDMCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000048u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_ERRMGMT_Data34[0]},	/* ERRMGMT */
+	{0x68u,	WRITE,	0x01u,	0x0000004Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIODAT_Data35[0]},	/* GPIODAT */
+	{0x68u,	WRITE,	0x01u,	0x0000004Du,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOOEN_Data36[0]},	/* GPIOOEN */
+	{0x68u,	WRITE,	0x01u,	0x0000004Eu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOIEN_Data37[0]},	/* GPIOIEN */
+	{0x68u,	WRITE,	0x01u,	0x00000050u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_PINTEN_Data38[0]},	/* PINTEN */
+	{0x68u,	WRITE,	0x01u,	0x00000051u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_PINTINV_Data39[0]},	/* PINTINV */
+	{0x68u,	WRITE,	0x01u,	0x00000052u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_PINCFG_Data40[0]},	/* PINCFG */
+	{0x68u,	WRITE,	0x01u,	0x00000020u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_TESTMODE_Data41[0]},	/* TESTMODE */
+	{0x68u,	WRITE,	0x01u,	0x00000059u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_CLK1CFG_Data42[0]},	/* CLK1CFG */
+	{0x68u,	WRITE,	0x01u,	0x0000005Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_CLK2CFG_Data43[0]},	/* CLK2CFG */
+	{0x68u,	WRITE,	0x01u,	0x00000081u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD0MSK_Data44[0]},	/* GPIOD0MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000082u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD1MSK_Data45[0]},	/* GPIOD1MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000083u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD2MSK_Data46[0]},	/* GPIOD2MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000084u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD3MSK_Data47[0]},	/* GPIOD3MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000085u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD4MSK_Data48[0]},	/* GPIOD4MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000086u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD5MSK_Data49[0]},	/* GPIOD5MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000087u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD6MSK_Data50[0]},	/* GPIOD6MSK */
+	{0x68u,	WRITE,	0x01u,	0x00000088u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIOD7MSK_Data51[0]},	/* GPIOD7MSK */
+	{0x68u,	WRITE,	0x01u,	0x0000008Au,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIODINV_Data52[0]},	/* GPIODINV */
+	{0x68u,	WRITE,	0x01u,	0x00000080u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_GPIODEN_Data53[0]},	/* GPIODEN */
+	{0x68u,	WRITE,	0x01u,	0x00000057u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2SRRCTL_Data54[0]},	/* I2SRRCTL */
+	{0x68u,	WRITE,	0x01u,	0x0000001Eu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_BECCTL_Data55[0]},	/* BECCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data56[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	WRITE,	0x01u,	0x0000000Du,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_DNSLOTS_Data52[0]},	/* DNSLOTS */
+	{0x69u,	WRITE,	0x01u,	0x0000000Eu,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_UPSLOTS_Data53[0]},	/* UPSLOTS */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x0000000Du,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_DNSLOTS_Data57[0]},	/* DNSLOTS */
+	{0x68u,	WRITE,	0x01u,	0x0000000Eu,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_UPSLOTS_Data58[0]},	/* UPSLOTS */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data59[0]},	/* NODEADR */
+
+	/*-- COMMANDS FOR DEVICE - A2B Slave Node0 WCZ --*/
+	{0x69u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BSlaveNode0WCZ_SWCTL_Data54[0]},	/* SWCTL */
+
+	/*-- COMMANDS FOR DEVICE - A2B Master Node0 58x EZ Board --*/
+	{0x68u,	WRITE,	0x01u,	0x00000009u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_SWCTL_Data60[0]},	/* SWCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000001u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_NODEADR_Data61[0]},	/* NODEADR */
+	{0x68u,	WRITE,	0x01u,	0x00000010u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_SLOTFMT_Data62[0]},	/* SLOTFMT */
+	{0x68u,	WRITE,	0x01u,	0x00000011u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_DATCTL_Data63[0]},	/* DATCTL */
+	{0x68u,	WRITE,	0x01u,	0x00000056u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_I2SRRATE_Data64[0]},	/* I2SRRATE */
+	{0x68u,	WRITE,	0x01u,	0x00000012u,	0x01u,	0x0001u,	&gaConfig_A2BMasterNode058xEZBoard_CONTROL_Data65[0]},	/* CONTROL */
+};
+
+#endif /* _ADI_A2B_I2C_LIST_H_ */
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 1dfad9187644..0acabf2b032f 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -350,6 +350,33 @@ config SND_SOC_IMX_WM8524
 	  Say Y if you want to add support for SoC audio on an i.MX board with
 	  a wm8524 codec.
 
+
+config SND_SOC_IMX_ADAU1361
+        tristate "SoC Audio support for i.MX boards with adau1361"
+        depends on OF && I2C
+        select SND_SOC_ADAU1761_I2C
+        select SND_SOC_IMX_PCM_DMA
+        select SND_SOC_FSL_SAI
+        select SND_SOC_FSL_UTILS
+        select SND_KCTL_JACK
+        help
+          SoC Audio support for i.MX boards with adau1361
+          Say Y if you want to add support for SoC audio on an i.MX board with
+          a adau1361 codec.
+
+config SND_SOC_IMX_A2B24XX
+         tristate "SoC Audio support for i.MX boards with A2B AD2428"
+         depends on OF && I2C
+         select SND_SOC_A2B24XX_I2C
+         select SND_SOC_IMX_PCM_DMA
+         select SND_SOC_FSL_SAI
+         select SND_SOC_FSL_UTILS
+         select SND_KCTL_JACK
+         help
+          SoC Audio support for i.MX boards with A2B AD2428
+          Say Y if you want to add support for SoC audio on an i.MX board with
+          a AD2428 A2B Bus.
+
 config SND_SOC_IMX_SII902X
 	tristate "SoC Audio support for i.MX boards with sii902x"
 	depends on OF && I2C
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index 0b23c8e74e41..dbf5b84f2c8e 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -78,6 +78,8 @@ snd-soc-imx-wm8958-objs := imx-wm8958.o
 snd-soc-imx-wm8960-objs := imx-wm8960.o
 snd-soc-imx-wm8524-objs := imx-wm8524.o
 snd-soc-imx-wm8962-objs := imx-wm8962.o
+snd-soc-imx-adau1361-objs := imx_adau1361v1.o
+snd-soc-imx-adau-a2b2428-objs := imx-adau-a2b2428.o
 snd-soc-imx-xtor-objs := imx-xtor.o
 snd-soc-imx-sii902x-objs := imx-sii902x.o
 snd-soc-imx-spdif-objs := imx-spdif.o
@@ -108,6 +110,8 @@ obj-$(CONFIG_SND_SOC_IMX_WM8524) += snd-soc-imx-wm8524.o
 obj-$(CONFIG_SND_SOC_IMX_WM8962) += snd-soc-imx-wm8962.o
 obj-$(CONFIG_SND_SOC_IMX_XTOR) += snd-soc-imx-xtor.o
 obj-$(CONFIG_SND_SOC_IMX_RPMSG) += snd-soc-imx-rpmsg.o
+obj-$(CONFIG_SND_SOC_IMX_ADAU1361) += snd-soc-imx-adau1361.o
+obj-$(CONFIG_SND_SOC_IMX_A2B24XX) += snd-soc-imx-adau-a2b2428.o
 obj-$(CONFIG_SND_SOC_IMX_SII902X) += snd-soc-imx-sii902x.o
 obj-$(CONFIG_SND_SOC_IMX_SPDIF) += snd-soc-imx-spdif.o
 obj-$(CONFIG_SND_SOC_IMX_MICFIL) += snd-soc-imx-micfil.o
diff --git a/sound/soc/fsl/imx-adau-a2b2428.c b/sound/soc/fsl/imx-adau-a2b2428.c
new file mode 100644
index 000000000000..6e7b8aa386a2
--- /dev/null
+++ b/sound/soc/fsl/imx-adau-a2b2428.c
@@ -0,0 +1,197 @@
+/*copyright (C) 2015-2019 Einfochips Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/control.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/syscon.h>
+
+#include "../codecs/adau17x1.h"
+
+struct imx_priv {
+	struct platform_device *pdev;
+	struct snd_soc_card card;
+	struct clk *codec_clk;
+	unsigned int clk_frequency;
+};
+
+static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int pll_rate;
+	int ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+
+	if (ret)
+	{
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret)
+	{
+		return ret;
+	}
+
+	switch (params_rate(params)) {
+	case 48000:
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 96000:
+		pll_rate = 48000 * 1024;
+		break;
+	case 44100:
+	case 7350:
+	case 11025:
+	case 14700:
+	case 22050:
+	case 29400:
+	case 88200:
+		pll_rate = 44100 * 1024;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0,0, 12288000, pll_rate);
+
+	if (ret)
+	{
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 2, pll_rate,
+			SND_SOC_CLOCK_IN);
+
+	if (ret)
+	{
+		return ret;
+	}
+	return ret;
+}
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.hw_params = imx_hifi_hw_params,
+};
+
+static struct snd_soc_dai_link imx_ad2428w_dai[] = {
+	{
+		.name = "a2b24xx",
+		.stream_name = "A2B24XX",
+		.codec_dai_name = "a2b24xx-hifi",
+		.ops = &imx_hifi_ops,
+	},
+};
+
+static int imx_ad2428w_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *codec_np = NULL;
+	struct platform_device *cpu_pdev;
+	struct imx_priv *priv;
+	struct platform_device *codec_pdev = NULL;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pdev = pdev;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "audio-cpu", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	priv->card.dai_link = imx_ad2428w_dai;
+
+	imx_ad2428w_dai[0].codec_of_node	= codec_np;
+	imx_ad2428w_dai[0].cpu_dai_name = dev_name(&cpu_pdev->dev);
+	imx_ad2428w_dai[0].platform_of_node = cpu_np;
+
+	priv->card.num_links = 1;
+	priv->card.dev = &pdev->dev;
+	priv->card.owner = THIS_MODULE;
+	priv->card.fully_routed = true;
+
+	ret = snd_soc_of_parse_card_name(&priv->card, "model");
+	if (ret)
+		goto fail;
+
+	snd_soc_card_set_drvdata(&priv->card, priv);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto fail;
+	}
+
+	ret = 0;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static const struct of_device_id imx_ad2428w_dt_ids[] = {
+	{ .compatible = "fsl,imx-ad2428w", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_ad2428w_dt_ids);
+
+static struct platform_driver imx_ad2428w_driver = {
+	.driver = {
+		.name = "a2b-DAI-driver",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_ad2428w_dt_ids,
+	},
+	.probe = imx_ad2428w_probe,
+};
+module_platform_driver(imx_ad2428w_driver);
+
+MODULE_AUTHOR("Parth Modi");
+MODULE_DESCRIPTION("Freescale i.MX AD2428w ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-thor96");
diff --git a/sound/soc/fsl/imx_adau1361v1.c b/sound/soc/fsl/imx_adau1361v1.c
new file mode 100644
index 000000000000..a4e3181f1840
--- /dev/null
+++ b/sound/soc/fsl/imx_adau1361v1.c
@@ -0,0 +1,227 @@
+/*copyright (C) 2015-2019 Einfochips Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/control.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/syscon.h>
+
+#include "../codecs/adau17x1.h"
+
+struct imx_priv {
+	struct platform_device *pdev;
+	struct snd_soc_card card;
+	struct clk *codec_clk;
+	unsigned int clk_frequency;
+};
+
+static const struct snd_soc_dapm_widget imx_adau1361_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("In 1", NULL),
+	SND_SOC_DAPM_LINE("In 2", NULL),
+	SND_SOC_DAPM_LINE("In 3-4", NULL),
+
+	SND_SOC_DAPM_LINE("Diff Out L", NULL),
+	SND_SOC_DAPM_LINE("Diff Out R", NULL),
+	SND_SOC_DAPM_LINE("Stereo Out", NULL),
+	SND_SOC_DAPM_HP("Capless HP Out", NULL),
+};
+
+static const struct snd_soc_dapm_route adau1361_dapm_routes[] = {
+	{ "LAUX", NULL, "In 3-4" },
+	{ "RAUX", NULL, "In 3-4" },
+	{ "LINP", NULL, "In 1" },
+	{ "LINN", NULL, "In 1"},
+	{ "RINP", NULL, "In 2" },
+	{ "RINN", NULL, "In 2" },
+
+	{ "In 1", NULL, "MICBIAS" },
+	{ "In 2", NULL, "MICBIAS" },
+
+	{ "Capless HP Out", NULL, "LHP" },
+	{ "Capless HP Out", NULL, "RHP" },
+	{ "Diff Out L", NULL, "LOUT" },
+	{ "Diff Out R", NULL, "ROUT" },
+	{ "Stereo Out", NULL, "LOUT" },
+	{ "Stereo Out", NULL, "ROUT" },
+};
+
+static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int pll_rate;
+	int ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+
+	if (ret) {
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+
+	if (ret) {
+		return ret;
+	}
+
+	switch (params_rate(params)) {
+	case 48000:
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 96000:
+		pll_rate = 48000 * 1024;
+		break;
+	case 44100:
+	case 7350:
+	case 11025:
+	case 14700:
+	case 22050:
+	case 29400:
+	case 88200:
+		pll_rate = 44100 * 1024;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, ADAU17X1_PLL,
+			ADAU17X1_PLL_SRC_MCLK, 12288000, pll_rate);
+
+	if (ret) {
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, ADAU17X1_CLK_SRC_PLL, pll_rate,
+			SND_SOC_CLOCK_IN);
+
+	return ret;
+}
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.hw_params = imx_hifi_hw_params,
+};
+
+static struct snd_soc_dai_link imx_adau1361_dai[] = {
+	{
+		.name = "adau1x61",
+		.stream_name = "adau1x61",
+		.codec_dai_name = "adau-hifi",
+		.ops = &imx_hifi_ops,
+	},
+};
+
+static int imx_adau1361_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *codec_np = NULL;
+	struct platform_device *cpu_pdev;
+	struct imx_priv *priv;
+	struct platform_device *codec_pdev = NULL;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pdev = pdev;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "audio-cpu", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	priv->card.dai_link = imx_adau1361_dai;
+
+	imx_adau1361_dai[0].codec_of_node	= codec_np;
+	imx_adau1361_dai[0].cpu_dai_name = dev_name(&cpu_pdev->dev);
+	imx_adau1361_dai[0].platform_of_node = cpu_np;
+
+	priv->card.num_links = 1;
+	priv->card.dev = &pdev->dev;
+	priv->card.owner = THIS_MODULE;
+	priv->card.dapm_routes = adau1361_dapm_routes;
+	priv->card.num_dapm_routes = ARRAY_SIZE(adau1361_dapm_routes);
+	priv->card.dapm_widgets = imx_adau1361_dapm_widgets;
+	priv->card.num_dapm_widgets = ARRAY_SIZE(imx_adau1361_dapm_widgets);
+	priv->card.fully_routed = true;
+
+	ret = snd_soc_of_parse_card_name(&priv->card, "model");
+	if (ret)
+		goto fail;
+
+	snd_soc_card_set_drvdata(&priv->card, priv);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto fail;
+	}
+
+	ret = 0;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static const struct of_device_id imx_adau1361_dt_ids[] = {
+	{ .compatible = "fsl,imx-adau1361", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_adau1361_dt_ids);
+
+static struct platform_driver imx_adau1361_driver = {
+	.driver = {
+		.name = "imx-adau1361",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_adau1361_dt_ids,
+	},
+	.probe = imx_adau1361_probe,
+};
+module_platform_driver(imx_adau1361_driver);
+
+MODULE_AUTHOR("Parth Modi");
+MODULE_DESCRIPTION("Freescale i.MX ADAU1361 ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-adau1361");
-- 
2.27.0

